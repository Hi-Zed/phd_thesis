%************************************************
\chapter[Related works]{Related works}\label{ch:Related}
%************************************************

Someone already did it?!? Ok, maybe no..

\begin{itemize}
\item Software engineering
	\begin{itemize}
	\item Component-Based Software Engineering
	\item Software Product Lines
	\item Model driven software development
	\item Automatic code generation
	\end{itemize}
\item System Design and Modelling
	\begin{itemize}
	\item General Purpose Modelling Languages
		\begin{itemize}
		\item UML
		\item AADL
		\end{itemize}
	\item Data modelling languages
		\begin{itemize}
		\item ASN.1
		\item JSON and JSON-schema
		\end{itemize}
        	\item Ontologies
	\end{itemize}
\item Domain specific approaches
	\begin{itemize}
	\item Automotive
	\item Smartphones
	\item Space
	\end{itemize}
\item Software development in robotics
	\begin{itemize}
	\item Middlewares and frameworks
	\item Robot Operating System
	\item Development tools
	\item Code generation
	\item Best practices and model based approaches
	\end{itemize}
\end{itemize}

\newpage

\section{Software engineering}
The definition given by the IEEE Computer Society for software engineering is: \textit{``the application of a systematic, disciplined, quantifiable approach to the development, operation and maintenance of software''}~\cite{abran2004software}. It is quite a broad statement, in fact, during the years, various experts gave their own definition~\cite{sommerville2011software, ieee1990ieee, pressman2005software} of what makes software engineering different from software development. Independently from the specific definition used to describe the field, it is undeniable that software engineering was born and it is used today to design, implement and manage complex computer programs.

From its humble inception in the 1960s as a label to legitimate the work done by the programmers in the Apollo missions, today software engineering evolved in a very complex field, including a long list of subdisciplines. Specialised software engineers work through the entire development process, starting from defining the software requirements, then creating the design, supervising the implementation, designing the testing approach, providing maintenance, and more.

Currently, robotics may not be ready to fully embrace the methodologies and techniques provided by software engineering, and at the same time, software engineers may not have all the necessary answer for roboticists' problems. However, given the rising importance of software in robotics~\cite{cousins2011exponential}, the overlap of the two world is inevitable. Indeed, robotics already benefited of this intersection by adopting component-based architectures~\cite{quigley2009ros, schlegel2014smartmdsd}, software product lines~\cite{gherardi2014modeling}, model-based designs~\cite{diego2010v3cmm}, and automatic programming~\cite{kumar2016rosmod}. Unfortunately, often these approaches fail to prosper in the robotic community and remain relegated to the academic world.

In this section, we analyse the software engineering side of these approaches, to understand they foundations, which affinity they had with robotics that pushed designers and developers to adopt them and how they can be integrated even further.

\subsection{Component-based Software Engineering}
Component-based software engineering (CBSE), also known as component-based development (CBD), is a software development approach where there is a strong emphasis on the separation of concerns. The architecture is divided in components, they encapsulate specific functionalities and interact between each other using pre-defined and clear interfaces.

The idea that software should be componentised is as old as software engineering itself, since it was originally proposed in the first NATO conference of software engineering in 1968. However modern component designs build on prior theories of architectures, frameworks and design patterns. In particular, they can be seen as the natural evolution of object oriented programming. The two development paradigm share various characteristics, for instance functionality encapsulation, information hiding, and well defined interfaces. In fact, often a component is implemented by a single object, or a main object defining the structure and multiple secondary objects to implements its functionalities.

A software component is very versatile, since they can be any kind of software entity, from high-level (\eg, software package or web service) to finer granularity (\eg, software module or web resource). However, the component needs to be consistent inside the same architecture, since they all follow the same component model. The component model is a specification of the concept of component to adapt to a given implementation. In most cases the definition of the model is quite loose (\eg, limited to the interface) and not formally specified, often imposed through other means (\eg, inheritance, forced parametrisation). However, when the component model is strictly formalised, CBSE is a stepping stone for model-based software engineering, a starting point to introduce the concept of formal methods to developers.

The advantage in the use of a component-based approach is an architecture that is extremely modular, functionalities are encapsulated, flexible, components communicates through interfaces, robust, unit testing and limited error propagation, and reusable, components are easy to port and replace. Robustness and re-usability are the two main characteristics of component-based architectures. Both are boosted by the encapsulation and the use of interfaces. Components are tested separately, and the behaviour of the architecture is simulated using the well-defined interfaces. Limiting the amount of functionalities in each component reduce the risk of faulty behaviours, streamline the development, and provides a clear overview of the role of the component in the architecture.

Robotics took great advantage from the characteristics of CBSE, the most popular approaches for robot software development use components as their foundations~\cite{brugali2009component, brugali2010component}. This is because of the intrinsic modular nature of robots, which is perfectly aligned with CBSE philosophy. Moreover, in robotics is quite challenging to perform testing, given the interaction with the real word, hence, an architecture where a sub-functionality can be replaced without modifying the supporting infrastructure is extremely beneficial. Unfortunately, the current state of the art in component-based robot software development is polarised on one of the two aspects of components. On one side, developers exploit the re-usability without pairing it with the expected robustness. For instance, this is happening in ROS, since it provides a vast library of existing components, but with total freedom left to the developer. On the opposite extreme, component models are significantly bound to the target architecture and framework that the re-usability is limited to that specific scenario. This is the case of SmartMDSD, they push for a more model-driven design, but the result is a constrained development environment. 

\subsection{Software product lines}
Software product lines are software-intensive systems sharing a common, managed set of features that satisfy the specific needs of a particular market segment or mission and that are developed from a common set of core assets in a prescribed way~\cite{northrop2002sei}. They are extensively used in automotive software development, and are adopted in multiple domains.

Conceptually, they are derived from the product line approach used in manufacturing, where product with similar characteristics are bundled together in a family of designs. These design families are manufactured in the same factory, where reusable parts are combined together to obtain one of the possible configurations of the product line.

In the same way, software product lines are a collection of similar software products that share a list of configurable features. A feature can be anything that specialises the software: a module, an algorithm, a service, a component. The product family share a reference architecture~\cite{nakagawa2011reference} that is used as the backbone of the configuration and specialisation process. All the possible product configuration and the configurable features are modelled using feature trees~\cite{mendonca2009splot, eriksson2009managing}. The features codified by the tree are usually targeted to functionalities (\eg, different type of communication, different planning methods, \etc), however, non-functional, yet measurable, properties have been used in some works~\cite{benavides2005automated} to specialise a product family.

Usually, a complete configuration of a product is a path from the root to one of the leaf of the tree, however, more complex configurations exists where two features can be implemented in parallel in the same product. In this cases, the final design of the software is determined by an overlap of all the complete root-to-leaf paths.

Following the same philosophy of the more constrained manufacturing product lines, the configuration of products in software product lines is defined at design-time. This means that after deployment, the software features are final and cannot be changed. However, software development is more flexible than traditional manufacturing, therefore exist an extension of SPLs that implements a dynamic approach to feature definition: dynamic software product lines. In DSPLs the definition of the architecture is postponed until runtime. Additionally, depending on the target platform, it is possible to ``hot swap'' the features during execution, adapting to the necessity of the software. SPLs is more in line with a monolithic development approach, where the entire software is completely defined before deployment, while DSPLs are more suitable for flexible approaches such as CBSE.

In fact, component-based software engineering is not in contrast with software product lines, on the contrary, the two approaches complete each other. CBSE promotes software reuse, however, it is often an opportunistic approach, components are developed for a functionality in a specific architecture and then shared with an extended community in the hypothesis of reuse. While this opportunistic reuse is successful in many cases~\cite{jansen2008pragmatic}, combining CBSE with SPLs lead to a more focused and forward-looking development. At the same time, a component-based architecture is ideal for implementing the philosophy proposed by SPLs, in particular considering the dynamic version, since plenty of component-based approaches support dynamic connection between components.

While in this work we will not discuss SPLs directly, many of our approaches can supports and are compatible with the feature system of software product line. For example, the bounded design of components, the templatisation of designs and the classification of functionalities. Moreover, SPLs have been successfully used in robotics for architecture modelling~\cite{gherardi2014modeling, brugali2016hyperflex} and for modelling of manipulation and grasping~\cite{baumgartl2013towards}.

\section{Model-driven Software engineering}
Model-driven software engineering takes the paradigm that a program is made by algorithms and data structures~\cite{wirth1986algorithms}, and evolves it in the concept that a software is made by models and transformations~\cite{brambilla2012model}. Models are used as a foundation for the design of the software and to support all the phases of the development cycle. They abstract specific aspects of the software to make it more understandable and manageable. Transformations are a set of rules defined by the software engineer that use the models as input to create programming artefacts or other, more detailed and more focused, models, in a recursive process that lead to a complete architecture. In summary, the software engineer goes from being a program developer to a system designer.

While this methodology seems more complicated than a traditional development approach, given it requires to learn modelling on top of programming and to introduce multiple new steps in the development process, it is actually extremely useful to manage complexity~\cite{selic2003pragmatics} and it increases efficiency and effectiveness in software development~\cite{acerbis2007developing}.

The most known and used application of MDSE is software development automation~\cite{sendall2003model}, where model-driven technique are employed to automate as much as possible of the software development process, from requirement definition to the system deployment. The process starts by a single or a collection of models and using a sequence of model-to-model transformation, where each phase use as an input the model (semi)automatically generated in the previous one, eventually manually refined by the specific domain expert. The last step is a model-to-text transformation where the chain of refined models converge in the final implementation. To achieve this result it is necessary for the model to be executable~\cite{mellor2002executable}, which means have all the necessary information to define an executable program.

This use case is also the focus of our work, since our main goal is to enchanter and streamline robot software development by hiding to the developer the unnecessary complexity introduced by robotic frameworks and middleware. However, this is only the one aspect of MDSE, since models can be used as a \textit{lingua franca}, not only between different domain expert working together on the same architecture, extremely important in robotics, which is often an overlap of multiple fields, but also between different technologies. For instance, ROS promotes thin implementations to increase its interoperability with other frameworks, however, when this happens it is always through manually implemented bridges that requires a lot of ad hoc conversions.

Model-driven approaches have been successfully used to promote system interoperability~\cite{chungoora2013model}, by abstracting relevant interfaces from the involved systems and providing a common communication ground. We use this strategy in this work with the support of ontologies (strictly related to modelling techniques~\cite{guizzardi2007ontology}), to create an abstraction layer on top of an existing robot architecture to create a generalised interface.

Another important use of MDSE is reverse engineering~\cite{bruneliere2010modisco, rugaber2004model}. Since models can be used to abstract software and highlight important aspect, they are the perfect tool to analyse legacy system and identify significant features, interfaces and functionalities that can be ported in a new system. While in this work we do not directly face this problem, our approach takes strongly into account the already existing solution and software artefacts for robotics. In particular, we model all the existing ROS components and messages, in a platform independent language, this representation could be used in the future to support the migration of ROS implementations to ROS2.
 
\subsection{General-purpose modelling languages}
Models are an abstract representation of a real system or a phenomenon~\cite{schichl2004models}. They are used in all fields of engineering, and, with no surprise, are central to model-driven software engineering. Models can appear in two forms: graphical representations (\eg, the blueprint of a building), or textual descriptions (\eg, a communication protocol description). 

Model, whether they are graphical or textual, are defined using a modelling language, which is an artificial language that can be used to express information and knowledge about a phenomena or a system using a consistent set of rules. A plethora of different modelling languages for software development exists, they cover different aspects of the architecture, or different phases of the development, or a targeted to specific platforms or subsystem. Often modelling languages try to provide a ``one-size-fits-all'' approach by achieving different levels of generality.

Probably the most known, and surely the most popular~\cite{malavolta2012industry}, general-purpose modelling language is the Unified Modeling Language~\cite{rumbaugh2004unified}. UML is defined, developed and maintained by the Object Management Group (OMG)~\cite{omg}, a not-for-profit technology standards consortium founded in 1989. UML has been evolving since the 1990s and has its roots in the object-oriented programming paradigm, nowadays, the current version of UML can be used to represent various programming and system artefacts. This makes UML a true general-purpose language, or almost a meta-language, since it can be specialised and refined for a specific domain using profiles~\cite{fuentes2004introduction}. 

The profile system in UML provides a generic extension mechanism to customize the language for specific domain or platforms. It allows to refine the standard semantic in a strictly additive way, preventing the extension from contradicting the general semantics. Given the extreme generality of UML and the size of the language, profiles have been used to design more focused modelling languages targeted to specific domains.

The Systems Modeling Language (SysML)~\cite{friedenthal2014practical} is a profile aimed to system engineers that supports design, analysis and validation of system architectures and system-of-systems designs. The design of SysML is based only on a subset of UML, and it tries to move away from its software-centric approach in favour of a more system-centric design. Another example of domain specific profile is Modeling and Analysis of Real Time Embedded system (MARTE)~\cite{faugere2007marte}, where UML is specialised to model non functional properties, physical constraints (\eg, time, mass, energy) or memory management in real-time and embedded systems. The list of available profiles is quite long, with applications in web development (WebML~\cite{ceri2000web}), service-oriented architectures (SoaML~\cite{elvesaeter2011model}), software product lines~\cite{ziadi2003towards}, data warehouses~\cite{lujan2006uml} and many more~\cite{fontoura2000uml, aldawud2001uml}. Unsurprisingly, the long list of UML profiles includes on specifically designed for robotics: the Robot Modeling Language (RobotML)~\cite{dhouib2012robotml}.

Given the scope of this work, we considered RobotML as a possible target modelling language for our approach. However, since it is based on UML, it is strongly software-centric, disregarding the importance of hardware descriptions in robotics. Moreover, the profile is only partially defined and lacks the sufficient documentation to use it as reliable and robust modelling language.

In summary, given its generality, UML and its profiles have been used as a silver bullet to solve any kind of modelling problem. However, the use of general purpose modelling languages, especially in extreme cases such as UML, may hinder the design approach instead of supporting it~\cite{simons199930, bonnet2016not}. Mostly because of the additional time necessary to learn the modelling languages on top of the domain-specific knowledge and because of the extreme abstraction between the model and the real application. Moreover, in UML, the profiles are powerful tools, but as often happen when significant customisation is available, they inevitably expand causing cross-dependencies~\cite{espinoza2009challenges}, nested specifications~\cite{faugere2007marte} and conflicts.

Another well known general-purpose modelling environment is Simulink~\cite{dabney2004mastering} developed by MathWorks and based on MATLAB. Simulink is far beyond the definition of modelling language since it implements a fully fledged modelling, simulation, and code generation system deeply integrated with MATLAB. It can be used to model an extreme variety of systems, from electronic circuits to image processing pipelines, passing through signal processing and analogue or digital control systems. It is based on a graphical block diagramming tool, originally designed to design control systems, and now extended to support a variety of different applications. Simulink embodies ``one-size-fits-all'' approach with its generalised modelling interface, this makes the interaction between models of similar domains simpler, but forces the designer to be extremely specialised and proficient in its modelling approach.

The strength of Simulink is also its significant downside. The strong integration with MATLAB makes the modelling suite extremely powerful, but also extremely limited to the functionality implemented by MathWorks. The freedom of choice of the developer is minimal, this means that all the phases of the modelling process have to happen in the boundaries defined by MATLAB. While this approach can be suitable for industrial setting, specific domains or high-level simulation, it is incompatible with the fast changing scenario~\cite{cousins2011exponential} of modern robotic applications.

The  Architecture Analysis \& Design Language (AADL)~\cite{feiler2006architecture} is a modelling language for architectures of safety-critical, embedded and real-time systems. Differently from other modelling languages, which focus on a graphical or textual description, AADL supports both, they can be used depending on the development phase or the required precision of the design. Due to its emphasis on the embedded domain, AADL contains constructs for modelling both software and hardware components. This architecture model can then be used either as a design documentation, for analyses~\cite{feiler2004open} (such as schedulability and flow control) or for code generation~\cite{hugues2008prototype} (of the software portion). While it is targeted to embedded system, AADL can be considered a general-purpose language, since its semantic is general enough to be used for various applications, from telecommunication~\cite{delanote2008using} to space~\cite{perrotin2011taste}.

AADL have been successfully used in robotics to perform analysis on latency and error propagation, both before the implementation of the architecture and after. In the former~\cite{biggs2014modelling}, an autonomous wheelchair has been modelled to define the redundancy of the system based on the expected error propagation. In the latter~\cite{larsen2016modelling}, an existing robot implementing a ROS-based architecture has been modelled to estimate the latency of the system and configure the nodes accordingly. However, outside of the approach presented in this work, AADL has yet to be used as a modelling language to describe robotic architectures and as a support tool for the entire development process. This is probably related to the fact that AADL is considered a niche modelling language with limited applications (\eg, latency analysis), in contrast to approaches such as UML.

\subsection{Data modelling languages}

\section{Ontologies}

\section{Domain-specific approaches}

\subsection{Automotive}
\subsection{Space}
\subsection{Smartphones}

\section{Software development in robotics}

\subsection{Middleware and frameworks}
\subsection{Development tools}
\subsection{Model-driven approaches}

%*****************************************
