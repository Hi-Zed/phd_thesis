%************************************************
\chapter[Related works]{Related works}\label{ch:Related}
%************************************************

In this chapter we present a list of technologies, techniques, methodologies and approaches related to the work presented in this thesis. We first introduce fundamentals concept of software engineering, then give an overview of the approaches used in the field that can be applied to robotics. After that, an overview of modelling languages and how they are used in domain-specific applications. The chapter closes by describing how the previously discussed methodologies and techniques are directly applied to robotics.

\minitoc
\newpage

\section{Software engineering}
The definition given by the IEEE Computer Society for software engineering is: \textit{``the application of a systematic, disciplined, quantifiable approach to the development, operation and maintenance of software''}~\cite{abran2004software}. It is quite a broad statement, in fact, during the years, various experts gave their own definition~\cite{sommerville2011software, ieee1990ieee, pressman2005software} of what makes software engineering different from software development. Independently from the specific definition used to describe the field, it is undeniable that software engineering was born and it is used today to design, implement and manage complex computer programs.

From its humble inception in the 1960s as a label to legitimate the work done by the programmers in the Apollo missions, today software engineering evolved in a very complex field, including a long list of subdisciplines. Specialised software engineers work through the entire development process, starting from defining the software requirements, then creating the design, supervising the implementation, designing the testing approach, providing maintenance, and more.

Currently, robotics may not be ready to fully embrace the methodologies and techniques provided by software engineering, and at the same time, software engineers may not have all the necessary answer for roboticists' problems. However, given the rising importance of software in robotics~\cite{cousins2011exponential}, the overlap of the two world is inevitable. Indeed, robotics already benefited of this intersection by adopting component-based architectures~\cite{quigley2009ros, schlegel2014smartmdsd}, software product lines~\cite{gherardi2014modeling}, model-based designs~\cite{diego2010v3cmm}, and automatic programming~\cite{kumar2016rosmod}. Unfortunately, often these approaches fail to prosper in the robotic community and remain relegated to the academic world.

In this section, we analyse the software engineering side of these approaches, to understand they foundations, which affinity they had with robotics that pushed designers and developers to adopt them and how they can be integrated even further.

\subsection{Component-based Software Engineering}
Component-based software engineering (CBSE), also known as component-based development (CBD), is a software development approach with  a strong emphasis on the separation of concerns. The architecture is divided in components, they encapsulate specific functionalities and interact between each other using pre-defined and clear interfaces.

The idea that software should be componentised is as old as software engineering itself, since it was originally proposed in the first NATO conference of software engineering in 1968. However modern component designs build on prior theories of architectures, frameworks and design patterns. In particular, they can be seen as the natural evolution of object oriented programming. The two development paradigm share various characteristics, for instance functionality encapsulation, information hiding, and well defined interfaces. In fact, often a component is implemented by a single object, or a main object defining the structure and multiple secondary objects to implements its functionalities.

A software component is very versatile, since they can be any kind of software entity, from high-level (\eg, software package or web service) to finer granularity (\eg, software module or web resource). However, the component needs to be consistent inside the same architecture, since they all follow the same component model. The component model is a specification of the concept of component to adapt to a given implementation. In most cases the definition of the model is quite loose (\eg, limited to the interface) and not formally specified, often imposed through other means (\eg, inheritance, forced parametrisation). However, when the component model is strictly formalised, CBSE is a stepping stone for model-driven software engineering, a starting point to introduce the concept of formal methods to developers.

The advantage in the use of a component-based approach is an architecture that is extremely modular, functionalities are encapsulated, flexible, components communicates through interfaces, robust, unit testing and limited error propagation, and reusable, components are easy to port and replace. Robustness and re-usability are the two main characteristics of component-based architectures. Both are boosted by the encapsulation and the use of interfaces. Components are tested separately, and the behaviour of the architecture is simulated using the well-defined interfaces. Limiting the amount of functionalities in each component reduce the risk of faulty behaviours, streamline the development, and provides a clear overview of the role of the component in the architecture.

Robotics took great advantage from the characteristics of CBSE, the most popular approaches for robot software development use components as their foundations~\cite{brugali2009component, brugali2010component}. This is because of the intrinsic modular nature of robots, which is perfectly aligned with CBSE philosophy. Moreover, in robotics is quite challenging to perform testing, given the interaction with the real word, hence, an architecture where a sub-functionality can be replaced without modifying the supporting infrastructure is extremely beneficial. Unfortunately, the current state of the art in component-based robot software development is polarised on one of the two aspects of components. On one side, developers exploit the re-usability without pairing it with the expected robustness. For instance, this is happening in ROS, since it provides a vast library of existing components, but with total freedom left to the developer. On the opposite extreme, component models are significantly bound to the target architecture and framework that the re-usability is limited to that specific scenario. This is the case of SmartMDSD, they push for a more model-driven design, but the result is a constrained development environment. 

\subsection{Model-driven Software engineering}
Model-driven software engineering takes the paradigm that a program is made by algorithms and data structures~\cite{wirth1986algorithms}, and evolves it in the concept that a software is made by models and transformations~\cite{brambilla2012model}. Models are used as a foundation for the design of the software and to support all the phases of the development cycle. They abstract specific aspects of the software to make it more understandable and manageable. Transformations are a set of rules defined by the software engineer that use the models as input to create programming artefacts or other, more detailed and more focused, models, in a recursive process that lead to a complete architecture. In summary, the software engineer goes from being a program developer to a system designer.

While this methodology seems more complicated than a traditional development approach, given it requires to learn modelling on top of programming and to introduce multiple new steps in the development process, it is actually extremely useful to manage complexity~\cite{selic2003pragmatics} and it increases efficiency and effectiveness in software development~\cite{acerbis2007developing}.

The most known and used application of MDSE is software development automation~\cite{sendall2003model}, where model-driven technique are employed to automate as much as possible of the software development process, from requirement definition to the system deployment. The process starts by a single or a collection of models and using a sequence of model-to-model transformations, where each phase use as an input the model (semi)automatically generated in the previous one, eventually manually refined by the specific domain expert. The last step is a model-to-text transformation where the chain of refined models converge in the final implementation. To achieve this result it is necessary for the model to be executable~\cite{mellor2002executable}, which means have all the necessary information to define an executable program.

This use case is also the focus of our work, since our main goal is to enhance and streamline robot software development by hiding to the developer the unnecessary complexity introduced by robotic frameworks and middleware. However, this is only the one aspect of MDSE, since models can be used as a \textit{lingua franca}, not only between different domain expert working together on the same architecture, extremely important in robotics, which is often an overlap of multiple fields, but also between different technologies. For instance, ROS promotes thin implementations to increase its interoperability with other frameworks, however, when this happens it is always through manually implemented bridges that requires a significant amount of ad hoc conversions.

Model-driven approaches have been successfully used to promote system interoperability~\cite{chungoora2013model}, by abstracting relevant interfaces from the involved systems and providing a common communication ground. We use this strategy in this work with the support of ontologies (strictly related to modelling techniques~\cite{guizzardi2007ontology}), to create an abstraction layer on top of an existing robot architecture to create a generalised interface.

Another important use of MDSE is reverse engineering~\cite{bruneliere2010modisco, rugaber2004model}. Since models can be used to abstract software and highlight important aspects, they are the perfect tool to analyse legacy systems and identify significant features, interfaces and functionalities that can be ported in a new system. While in this work we do not directly face this problem, our approach takes strongly into account the already existing solutions and software artefacts for robotics. In particular, we model all the existing ROS components and messages, in a platform independent language, this representation could be used in the future to support the migration of ROS implementations to ROS2.

\subsection{Software product lines}
Software product lines are software-intensive systems sharing a common, managed set of features that satisfy the specific needs of a particular market segment or mission and that are developed from a common set of core assets in a prescribed way~\cite{northrop2002sei}. They are extensively used in automotive software development, and are adopted in multiple domains.

Conceptually, they are derived from the product line approach used in manufacturing, where product with similar characteristics are bundled together in a family of designs. These design families are manufactured in the same factory, where reusable parts are combined together to obtain one of the possible configurations of the product line.

In the same way, software product lines are a collection of similar software products that share a list of configurable features. A feature can be anything that specialises the software: a module, an algorithm, a service, a component. The product family share a reference architecture~\cite{nakagawa2011reference} that is used as the backbone of the configuration and specialisation process. All the possible product configuration and the configurable features are modelled using feature trees~\cite{mendonca2009splot, eriksson2009managing}. The features codified by the tree are usually targeted to functionalities (\eg, different type of communication, different planning methods, \etc), however, non-functional, yet measurable, properties have been used in some works~\cite{benavides2005automated} to specialise a product family.

Usually, a complete configuration of a product is a path from the root to one of the leaf of the tree, however, more complex configurations exists where two features can be implemented in parallel in the same product. In this cases, the final design of the software is determined by an overlap of all the complete root-to-leaf paths.

Following the same philosophy of the more constrained manufacturing product lines, the configuration of products in software product lines is defined at design-time. This means that after deployment, the software features are final and cannot be changed. However, software development is more flexible than traditional manufacturing, therefore an extension of SPLs that implements a dynamic approach to feature definition exists: dynamic software product lines. In DSPLs the definition of the architecture is postponed until runtime. Additionally, depending on the target platform, it is possible to ``hot swap'' the features during execution, adapting to the necessity of the software. SPLs is more in line with a monolithic development approach, where the entire software is completely defined before deployment, while DSPLs are more suitable for flexible approaches such as CBSE.

In fact, component-based software engineering is not in contrast with software product lines, on the contrary, the two approaches complete each other. CBSE promotes software reuse, however, it is often an opportunistic approach, components are developed for a functionality in a specific architecture and then shared with an extended community in the hypothesis of reuse. While this opportunistic reuse is successful in many cases~\cite{jansen2008pragmatic}, combining CBSE with SPLs lead to a more focused and forward-looking development. At the same time, a component-based architecture is ideal for implementing the philosophy proposed by SPLs, in particular considering the dynamic version, since plenty of component-based approaches support dynamic connection between components.

While in this work we will not discuss SPLs directly, many of our approaches can supports and are compatible with the feature system of software product line. For example, the bounded design of components, the templatisation of designs and the classification of functionalities. Moreover, SPLs have been successfully used in robotics for architecture modelling~\cite{gherardi2014modeling, brugali2016hyperflex} and for modelling of manipulation and grasping~\cite{baumgartl2013towards}.
 
\section[General-purpose modelling languages]{General-purpose modelling\\languages}
Models are an abstract representation of a real system or a phenomenon~\cite{schichl2004models}. They are used in all fields of engineering, and, with no surprise, are central to model-driven software engineering. Models can appear in two forms: graphical representations (\eg, the blueprint of a building), or textual descriptions (\eg, a communication protocol description). 

Model, whether they are graphical or textual, are defined using a modelling language, which is an artificial language that can be used to express information and knowledge about a phenomena or a system using a consistent set of rules. A plethora of different modelling languages for software development exists, they cover different aspects of the architecture, or different phases of the development, or they are targeted to specific platforms or subsystem. Often modelling languages try to provide a ``one-size-fits-all'' approach by achieving different levels of generality.

\paragraph{Unified Modeling Language} Probably the most known, and surely the most popular~\cite{malavolta2012industry}, general-purpose modelling language is the Unified Modeling Language~\cite{rumbaugh2004unified}. UML is defined, developed and maintained by the Object Management Group (OMG)~\cite{omg}, a not-for-profit technology standards consortium founded in 1989. UML has been evolving since the 1990s and has its roots in the object-oriented programming paradigm, nowadays, the current version of UML can be used to represent various programming and system artefacts. This makes UML a true general-purpose language, or almost a meta-language, since it can be specialised and refined for a specific domain using profiles~\cite{fuentes2004introduction}. 

The profile system in UML provides a generic extension mechanism to customize the language for specific domain or platforms. It allows to refine the standard semantic in a strictly additive way, preventing the extension from contradicting the general semantic. Given the extreme generality of UML and the size of the language, profiles have been used to design more focused modelling languages targeted to specific domains.

The Systems Modeling Language (SysML)~\cite{friedenthal2014practical} is a profile aimed to system engineers that supports design, analysis and validation of system architectures and system-of-systems designs. The design of SysML is based only on a subset of UML, and it tries to move away from its software-centric approach in favour of a more system-centric design. Another example of domain specific profile is Modeling and Analysis of Real Time Embedded system (MARTE)~\cite{faugere2007marte}, where UML is specialised to model non functional properties, physical constraints (\eg, time, mass, energy) or memory management in real-time and embedded systems. The list of available profiles is quite long, with applications in web development (WebML~\cite{ceri2000web}), service-oriented architectures (SoaML~\cite{elvesaeter2011model}), software product lines~\cite{ziadi2003towards}, data warehouses~\cite{lujan2006uml} and many more~\cite{fontoura2000uml, aldawud2001uml}. Unsurprisingly, the long list of UML profiles includes one specifically designed for robotics: the Robot Modeling Language (RobotML)~\cite{dhouib2012robotml}.

Given the scope of this work, we considered RobotML as a possible target modelling language for our approach. However, since it is based on UML, it is strongly software-centric, disregarding the importance of hardware descriptions in robotics. Moreover, the profile is only partially defined and lacks the sufficient documentation to use it as reliable and robust modelling language.

In summary, given its generality, UML and its profiles have been used as a silver bullet to solve any kind of modelling problem. However, the use of general purpose modelling languages, especially in extreme cases such as UML, may hinder the design approach instead of supporting it~\cite{simons199930, bonnet2016not}. Mostly because of the additional time necessary to learn the modelling languages on top of the domain-specific knowledge and because of the extreme abstraction between the model and the real application. Moreover, in UML, the profiles are powerful tools, but as often happen when significant customisation is available, they inevitably expand causing cross-dependencies~\cite{espinoza2009challenges}, nested specifications~\cite{faugere2007marte} and conflicts.

\paragraph{Simulink} Another well known general-purpose modelling environment is Simulink~\cite{dabney2004mastering} developed by MathWorks and based on MATLAB. Simulink is far beyond the definition of modelling language since it implements a fully fledged modelling, simulation, and code generation system deeply integrated with MATLAB. It can be used to model an extreme variety of systems, from electronic circuits to image processing pipelines, passing through signal processing and analogue or digital control systems. It is based on a graphical block diagramming tool, originally designed to design control systems, and now extended to support a variety of different applications. Simulink embodies the ``one-size-fits-all'' approach with its generalised modelling interface, this makes the interaction between models of similar domains simpler, but forces the designer to be extremely specialised and proficient in its modelling approach.

The strength of Simulink is also its significant downside. The strong integration with MATLAB makes the modelling suite extremely powerful, but also extremely limited to the functionality implemented by MathWorks. The freedom of choice of the developer is minimal, this means that all the phases of the modelling process have to happen in the boundaries defined by MATLAB. While this approach can be suitable for industrial setting, specific domains or high-level simulation, it is incompatible with the fast changing scenario~\cite{cousins2011exponential} of modern robotic applications.

\paragraph{Architecture Analysis \& Design Language} The  Architecture Analysis \& Design Language (AADL)~\cite{feiler2006architecture} is a modelling language for architectures of safety-critical, embedded and real-time systems. Differently from other modelling languages, which focus on a graphical or textual description, AADL supports both, they can be used depending on the development phase or the required precision of the design. Due to its emphasis on the embedded domain, AADL contains constructs for modelling both software and hardware components. This architecture model can then be used either as a design documentation, for analyses~\cite{feiler2004open} (such as schedulability and flow control) or for code generation~\cite{hugues2008prototype} (of the software portion). While it is targeted to embedded system, AADL can be considered a general-purpose language, since its semantic is general enough to be used for various applications, from telecommunication~\cite{delanote2008using} to space~\cite{perrotin2011taste}.

AADL have been successfully used in robotics to perform analysis on latency and error propagation, both before the implementation of the architecture and after. In the former~\cite{biggs2014modelling}, an autonomous wheelchair has been modelled to define the redundancy of the system based on the expected error propagation. In the latter~\cite{larsen2016modelling}, an existing robot implementing a ROS-based architecture has been modelled to estimate the latency of the system and configure the nodes accordingly. However, outside of the approach presented in this work, AADL has yet to be used as a modelling language to describe robotic architectures and as a support tool for the entire development process. This is probably related to the fact that AADL is considered a niche modelling language with limited applications (\eg, latency analysis), in contrast to approaches such as UML.

\section{Domain-specific approaches}
Domain-specific approaches vary in complexity and connection to the domain depending on how much they are defined specifically for a given domain. The most general form of domain specialisation is the concept of a Domain-specific language (DSL)~\cite{fowler2010domain}.  A DSL is created by defining a programming language with a limited expressiveness designed specifically for a particular set of tasks. Often, the level of specialisation is such that the language is tailored on a specific category of users~\cite{voelter2013dsl}. DSL are often derived from a more general language used as a guideline, a typical example is the markup meta-language XML~\cite{harold1998xml} that can be used to define specific languages following a predefined schema. However, when used for larger domains they are usually created from scratch, to the point that it is difficult to recognise them as domain-specific (\eg, HTML~\cite{graham1995html} or AWK~\cite{dougherty1997sed}).

While special-purpose computer languages have always existed, the term ``domain-specific language'' has become more popular due to the rise of domain-specific modelling. In fact, modelling benefits significantly from DSL, since they can be used to reduce complexity and to provide a dialect of an original general-purpose language to target a specific domain, a clear example is the use of profiles in UML. Given the importance of DSL in modelling, there are various MDSE environments enabling their creation. For instance, the Eclipse Foundation provide a collection of tools under the Eclipse Modeling Project~\cite{gronback2009eclipse} where Ecore~\cite{steinberg2008emf, sciamma2013ecore} is used for meta-modelling, Papyrus~\cite{lanusse2009papyrus} for UML profiles and general modelling, Xtext~\cite{eysholdt2010xtext} specifically for DSL engineering, and Xtend~\cite{bettini2016implementing} for code-generation. Other examples are the Jetbrains Meta Programming System (MPS)~\cite{mps}, specifically designed as a complete environment for the creation of DSL, and MontiCore Language Workbench~\cite{krahn2010monticore}, a modular workbench for the design and realization of textual DSLs, which has been used with some degrees of success to create robotic specific languages~\cite{thomas2013new}.

In this work we recognise the usefulness of DSLs in model-driven approaches, in fact, we defined ourself one based on XML to create an intermediate representation from AADL (Section~\ref{sec:aadl-to-aaxml}). Additionally, while defining our meta-model, we pondered the possibility of defining a DSL to reduce the complexity of the model. In the end, we realised that AADL already provided, through inheritance, tools to manage the complexity of the language, without the need of  hindering the freedom of the designer.

\subsection{Automotive}
The Automotive Open System Architecture (AUTOSAR)~\cite{furst2009autosar} is the perfect example of a complete domain-specific environment, where the entire development stack (\ie, design, implementation and ecosystem) has been design for a specific field. AUTOSAR is a worldwide development partnership of automotive interested parties founded in 2003. It pursues the objective of creating and establishing an open and standardized software architecture for automotive electronic control units (ECUs). Goals include the scalability to different vehicle and platform variants, transferability of software, the consideration of availability and safety requirements, a collaboration between various partners, sustainable utilization of natural resources, and maintainability throughout the whole product life cycle~\cite{autosar}.

AUTOSAR is based on a three-layered architecture: the basic software, a series of standardised modules necessary to run the functional part of the upper software layers, the runtime environment, a middleware which abstract the network topology for all the necessary communications, and the application layer, the application software components implementing specific functionalities. This structure is not particularly different from what is currently happening in robotics, however, there are two significant difference that make AUTOSAR a industry-accepted standard, while in robotics there is no consensus yet.

First and foremost, AUTOSAR is an industry-created and in\-dus\-try-imposed standard. It is a top down approach where the biggest actors of the automotive industry lobbied together to create a standard. In robotics, the approaches are bottom up and self-emerging. Second is the superstructure of tools, methodologies, standards, and practices associated with AUTOSAR~\cite{arts2015testing, anssi2011enabling, giese2010model}. Robotics should learn from the results obtained by the automotive industry, but not by copying the top down approach of imposing a standard, but by providing the necessary superstructure to the existing self-emerging approaches.

\subsection{Space}
The development of space applications is significantly different from traditional development. Considering the limitation imposed by the harsh environments, the physical constraint impacting the software (\eg, weight of the hardware components), the one-time deployment, and the extreme criticality of the implementations, it comes with no surprise that approaches, tooling and methodologies for space applications are extremely domain specific.

TASTE is a toolchain targeting heterogeneous, embedded systems using a model-driven development approach~\cite{perrotin2010taste}. In space applications software is usually categorised depending on the final deployment, prototypes are often developed with less restrictions and then deployed using space-grade technologies before a mission. In this scenario, TASTE is a laboratory platform designed for experimenting new software technologies, based on free and open source solutions. TASTE has at its core the philosophy of ``not reinventing the wheel'', therefore, while it is designed for the very restrictive space domain, all its functionalities are build on top of existing technologies and reusable designs and approaches.

At its core, TASTE is based on AADL for the architectural models and on ASN.1 for data models~\cite{perrotin2011taste}. Additionally, thanks to its modular design and the property system of AADL, it supports VHDL~\cite{navabi1997vhdl} for hardware design, SDL for behaviour modelling, and Simulink for dynamic simulations. TASTE is a complete toolchain from the model definition, using a superstructure built on top of AADL, to the execution platform, it supports code generation and deployment on real-time platform such as Xenomai~\cite{gerum2004xenomai} and PolyORB-HI~\cite{vergnaud2004polyorb}.

The approach chosen by TASTE is remarkable and extremely interesting. TASTE is developed and maintained directly by the European Space Agency, an organisation that has the power to impose standards to their contractors. However, they decided to adopt existing approaches and use them to support their work. This strategy is compatible with the self-emerging robotic environment, instead of imposing new standards, exploit existing technologies to support popular approaches.

%\section{Ontologies}

\section{Robot software development}
Robot software development is very different with respect to other domains. To be more precise, robotics does not face unique challenges, but it combines in a single domain multiple issues seen and managed independently by other fields. Robot software is bound to the hardware as much as embedded systems, and it may requires the low-latency provided by real-time architecture. Additionally, a wide variety of robotic systems have to perform direct interaction with humans, facing the same challenges of human-computer interactions and user interface development. Robots are equipped with multiple sensors and actuators implementing multiple functionalities, this requires architectures to be flexible and modular. Lastly, the interaction with the environment is tightly connected with the internal execution loop of the robot, making the intrinsic uncertainty of the real world a guiding element of robot design. This characteristic is almost unique to robotics, a similar level of uncertainty is found in web applications given the interaction with the Internet. The main difference between the two is that a robot needs to understand and interface with the uncertainty of the real world, while a web application tries to bound and constraint it.

\subsection{Middleware and frameworks}
Both the state of the art and the history of robot software revolves around the concept of middleware or frameworks. Systems used to hide the complexity of the underlying hardware platform and to help the developers in creating, deploying and reusing modular implementations. Right now the landscape for robot development is quite consolidated with the current technologies celebrating their 10\textsuperscript{th} anniversary and the pioneers getting closer to their 20\textsuperscript{th} birthday.

Player~\cite{gerkey2003player} is one of the first frameworks for robotics, its aim was to provide support for the development of device drivers. It become very successful, especially because it allowed to integrate and reuse third party software~\cite{vaughan2007reusable}. Another key element of its popularity was its twin platform: the Stage simulator. A contemporary of the Player/Stage project is the Open Robot Control Software Real Time Toolkit (OROCOS-RTT)~\cite{bruyninckx2001open}, a framework designed to provide real-time capabilities for industrial robots and manipulators. OROCOS introduced the concept of using component-based architectures for robotics by basing its implementation on the Common Object Request Broker Architecture (CORBA)~\cite{otte1996understanding}. Moreover, the OROCOS project tried to push good practices for robotics, by creating a modular toolchain promoting interoperability between frameworks, separation of concerns~\cite{bruyninckx2003real}, and component libraries~\cite{bruyninckx2002orocos}.

The design choice of OROCOS of using CORBA and a component-based approach proved to be successful, today the framework is still used in application where hard real-time is a requirement. However, implementing real-time software is a difficult task not needed for a fair amount of robotic applications. This spawned new approaches based on OROCOS and CORBA with the aim of supporting a wider variety of robots. Orca~\cite{brooks2007orca} implements a component-based design originally based on CORBA and then migrated to the Internet Communication Engine (ICE)~\cite{ICE}. The focus of Orca is on component re-usability, by defining a set of commonly-used interfaces and by providing libraries with high-level APIs. Another framework born from the premises of OROCOS is the Robot Construction Kit (RoCK)~\cite{joyeux2011robot}. RoCK si built on top of OROCOS, it provides a tool called oroGen that can be used to automatically generate OROCOS component skeletons. RoCK tries to use an automatic programming approach to ease the implementation of real-time component while maintaining intact their properties. An interesting feature of this framework is the focus on separating the problem-specific implementation from the framework-related code. Developers use oroGen to create the skeleton of the components, but they implement the functionalities in separate libraries that are connected at deployment time.

Given the variability of robots, plenty of different frameworks and middleware specialising on a specific aspect exist. 
\begin{itemize}
\item Yet another Robot Platform (YARP)~\cite{metta2006yarp} is a middleware which focus on providing a peer-to-peer architecture supporting an extensible variety of protocols (\eg, TCP, UDP, multicast, MPI, XML/RPC, \etc). It is used mostly in research and academia for humanoid robots requiring fast and reactive control loops. 
\item OpenRTM-aist~\cite{ando2008software} is a framework based on the Robotic Technology Middleware (RT-Middleware)~\cite{ando2005rt}. The RT-Middleware is a common platform standard for robot based on distributed object technology supported and maintained by the Object Management Group. OpenRTM-aist is an implementation that represents the robot as a system of systems where all the functionalities are identified by components.
\item Fawkes~\cite{niemueller2010design} is a component-based approach for robotics. Its main design characteristics are a blackboard-based messaging system, a Lua-based engine for robotic behaviours, and a monolith plug-in architecture.
\item SmartSoft~\cite{schlegel1999software} is a service-oriented component-based framework. It revolves around the idea of providing \textit{freedom from choice} to the developer. Originally, it was done by providing a limited amount of communication pattern to the developer. More recently, SmartSoft has been extended into SmartMDSD~\cite{dennis2016smartmdsd} to strongly support a model-driven approach.
\end{itemize}

Currently, the most popular and most used middleware~\cite{elkady2012robotics} for robotic is the Robot Operating System (ROS)~\cite{quigley2009ros}. Like many others, the technological core of ROS is a component-based framework. Components, called nodes, are organised in a peer-to-peer network where messages are exchanged using synchronous or asynchronous communication channels. Practically speaking, the framework part of ROS is deliberately thin; ROS does not provide a component model for the description of nodes and gives to the developer total freedom. The main reason of the popularity of ROS is its community; the unconstrained development approach resulted in thousands of developers adopting ROS and sharing their implemented components.

Despite its popularity and adoption, ROS is not without flaws. The main critique to ROS has always been the lack of support for real-time application and industrial setting. This has given rise to various initiatives, first and foremost, ROS2~\cite{ros2}, a new iteration of ROS adopting the Data Distribution Service (DDS)~\cite{pardo2003omg} as the underlying connectivity framework. ROS Industrial~\cite{edwards2012ros} is an initiative that aims to apply ROS to industrial settings by providing certified modules compatible with a list of recognised industrial robot. In this context, the ROSIN project~\cite{rosin} aims to apply a model-driven approaches as a system to certify these modules.

\subsection{Model-driven approaches}
%SmartMDSD ROSMOD RobMoSys BRICS BRIDE Hyperflex 
Given the complexity of robotic systems and robot development, various approaches based on models and software engineering techniques have emerged in robotics during the years. They can be divided in three different categories: domain specific languages, model-driven robotic frameworks, and global initiatives.

Domain specific languages are well suited for robot development, since a robotic system is a collection of subsystems, and each of them can be tackled by a specific DSL. For example, \cite{steck2011managing} and \cite{klotzbucher2012coordinating} developed a DSL for task coordination, in~\cite{hochgeschwender2013model} it is used to model and deploy ROS nodes, and \cite{gherardi2011eclipse} in combination with a SPL to model reference architectures. An extensive overview of DSLs for robotic can be found in~\cite{nordmann2014survey}. Since they are designed for a specific task, DSLs can be extremely powerful and useful. However, given their narrow focus they often fail to scale and to be adaptable to evolution of the targeted domain. Moreover, often multiple DSLs exists to accomplish the same task since their domain-bound nature triggers the ``Not Invented Here'' syndrome, and push designers to create a new language.

Robotic frameworks are the perfect target to be extended or built following a model-driven philosophy. They already implement a component-based architecture, which is usually completed by a component model, with varying degrees of formality. The most complete case of a model-driven robotic framework is SmartMDSD~\cite{dennis2016smartmdsd}, the most recent evolution of SmartSoft. They provide a complete, model-driven development environment built on top of Eclipse. They promote ``freedom from choice'' by limiting the developer options through a strict design approach and automatic code generation. A model-driven approach built on top of ROS is ROSMOD~\cite{kumar2016rosmod}. They developed a component model for ROS nodes to support rapid prototyping and collaborative development. The result is an hybrid approach between ROS functionalities and a custom-made implementation.

Robotics is a very diverse field, robots can have a great variety of configurations and applications, however, robotic frameworks all gravitated toward the same modular and component-based design. Given these similarities, global efforts have been made to create general and framework-independent modelling approaches for robotics. Best Practices in Robotics (BRICS)~\cite{bischoff2010brics} was an European FP7 focusing on component-based development for robot software and on the formalisation of existing best practices through MDSE. The project had three main outputs: the BRICS Component Model (BCM)~\cite{bruyninckx2013brics}, an Integrated Development Environment (BRIDE)~\cite{bubeck2014bride} and the Open Code Repository (BROCRE)~\cite{kraetzschmar2010specifications}.

BCM is a component model which aim is to provide a general abstraction for robotic frameworks. However, in an effort to accommodate all the most used framework at the time, the resulting model is quite general and only covers the common structures, for instance, communication details are not present at component level. Nevertheless, BCM succeeded in showing how closely related components from different frameworks are, and it was an important starting point for the work of this thesis. BRIDE is a model-driven tool for component design based on the BCM. It provide automatic code generation for OROCOS and ROS. BROCRE is an online platform to collect, search and install all the component following the BCM.

RobMoSys (Composable Models and Software for Robotics)~\cite{robmosys} is an Horizon 2020 project part of the European efforts to create an EU digital industrial platform for robotics. The project focuses on a model-driven composition-oriented approach to system integration and ecosystem building for robotics. The current output of the project is a collection of meta-models for components, communication protocols, architecture definition, and more. While RobMoSys presents itself as a general approach aimed at promoting system composition and re-usability, all of its meta-modelling infrastructure is based on the design of SmartMDSD. This strongly limit the interoperability with other robotic frameworks, however, it pushes developer in creating framework-independent tools, to be compatible both with RobMoSys and ROS.

%*****************************************
