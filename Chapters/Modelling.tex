%************************************************
\chapter[Modelling]{Modelling}\label{ch:Modelling}
%************************************************

\begin{flushright}{\slshape the sciences do not try to explain, they hardly even try to interpret, they mainly make models. By a model is meant a mathematical construct which, with the addition of certain verbal interpretations, describes observed phenomena.} \\ \medskip
    --- John  von Neumann
\end{flushright}

As said by von Neumann, science is about making models. They can be used to simplify a phenomena and make it easier to understand and define, moreover, a model can be used to quantify or visualise reality. Knowledge extracted by the process of modelling can be reused to create a simulation (\ie, another form of modelling) of the system under analysis. For all these reasons, and because is one of the most innate ability of humans, modelling has always been the cornerstone of science, engineering and arts.

Modelling in engineering is an essential tool for design, analysis and simulation, models have different characteristics and take various shapes. A collection of mathematical formulas can be used to describe a physical phenomena (\eg, friction between the ground and the wheels), or the behaviour of a system (\eg, a control system). Differently, a flow chart is a graphical model of an execution process, while pseudo-code is a textual one. A 3D model capture the physical shape of an object and can be used to study the design or the space occupancy.

This chapter presents various modelling techniques that we used to describe multiple aspect of the architecture of a robot. First, an introduction to the  Architecture Analysis \& Design Language (AADL), a description of the concepts behind the language and how it can be used to model complex system. Then, how the language is exploited to model robotic system and more in particular ROS-based architectures.  Lastly, since AADL is not a data modelling language, we present two approaches based on Abstract Syntax Notation One (ASN.1) and JavaScript Object Notation (JSON) to model the data exchanged in the system (\ie, ROS messages) and the internal state of each component.

\minitoc
\newpage

\section{Architecture Analysis \& Design Language}
The Architecture Analysis \& Design Language is a very powerful modelling language designed to capture the architecture of embedded systems by using architectural models that provide a well-defined and semantically rich description of the runtime architecture. This description encompasses multiple aspects of the system: hardware components, to encode the underlying physical layer of the system, software components, to define the runtime behaviour of the architecture, the interaction between them, for example deployment of software on specific hardware and communication between different execution units, and the defining properties of each modelled element, to better characterise any particular system.

 In AADL, components are defined using a dichotomy between specification and implementation. The component type declaration is used to define the category (see Table~\ref{tab:categories}) and the interfaces (\ie, features) of the component; this correspond to a specification sheet that provides a description of the component as a black box. For a specific type it is possible to define multiple component implementation declarations, each of them defines internal structure of the component (\ie, subcomponents and their interactions). This is equivalent as defining multiple blueprints for building a component from its parts, each of them a possible implementation of an already defined specification. To specify even more the characteristics of a component, especially its runtime behaviour, it is possible to use properties. AADL already provides a collection of predefined properties, and more are available by including standard annexes for specific analyses, moreover, an user can defined his own properties by defining additional properties sets. Together, all these declarations (\ie, type with implementation whit a set of properties) define a pattern for a component, which are referred as component classifiers.
 
\begin{table}
    \myfloatalign
    \begin{tabularx}{\textwidth}{ l X} \toprule
        \tableheadline{Category} & \tableheadline{description} \\ \midrule
        \multicolumn{2}{c}{Application software} \\ \midrule
        data & Abstraction for data units.  \\
        thread & A schedulable execution path. \\
        thread group & An abstraction to logically organise threads. \\
        process & Execution unit with a protected address space.  \\
        subprogram & Callable sequentially executable code. It represents call-return functions.  \\
        subprogram group & An abstraction to logically organise subprograms. \\ \midrule
        \multicolumn{2}{c}{Execution platform} \\ \midrule
        processor & Schedule and executes threads and virtual processors. \\
        virtual processor & Logical resource that can schedule and executes threads. It must be bound to one or more physical processor. \\
        memory & Stores code and data. \\
        bus & Interconnects processors, memory and devices. \\ \midrule
        \multicolumn{2}{c}{Composite} \\ \midrule
        system & Integrates software, hardware and other system components. \\ \midrule
        \multicolumn{2}{c}{Generic} \\ \midrule
        abstract & Define a runtime neutral component that can be refined into another component category. \\
        \bottomrule
    \end{tabularx}
    \caption[Component categories]{Component categories.}  \label{tab:categories}
\end{table}
 
Component types and implementations are defined and organised using packages; they are, essentially, libraries of component specifications that can be used in multiple architecture definitions. Packages have public and private sections to support information hiding. The public section of a package contains all the specification that will be available to other packages, while the private section can be used to hide the specific component implementation. In AADL, everything is organised in packages, an exception are property set. They are special container for user-defined properties, they act like packages and can be imported in other definition, but only properties can be defined in properties set.

To model a full architecture it is necessary to first define all the necessary component classifiers, or import the existing ones in previously defined packages. In the case of a robot, for example, it is necessary to define the physical sensors as devices and the execution platform as a combination of processors, buses and memories. On the software side, the designer could import previously defined software component as processes or define more in new packages and then import them. After this initial definition, a complete architectural description is created by integrating in a fully specified system implementation instances of the previously defined component classifiers. This hierarchy represents all the interactions between components and the architectural structure of the modelled system. These interactions cover multiple aspect of the system, they encode the communication between components through data and events, and the physical connections between them. They also capture the assignment of software to hardware (\eg, on which physical processor or processing unit a specific process will be executed). The full model of the system under analysis is obtained by instantiating this top level system implementation. This instance model can the be used to analyse operational properties of the system, ranging from syntactic compliance and basic interface data consistency to assessment of quality attributes and behaviours.

The key characteristics that make AADL suitable for our approach are the inheritance between components and the possibility to use partially defined components and interfaces that can be refined later in the design process. In practice, inheritance exists as a form of extension of existing components. A new classifier (\ie, component type and implementations) can be defined by extending an existing one; the extended classifier inherits all the characteristics of the base one: interfaces, subcomponents, properties, internal connections and modes. The extension declaration can be used to refine the new classifier by adding new elements, specifying existing elements inherited from the base classifier, restricting subcomponents to a specific mode, completing the definition of partially defined sections. Partial definition is achieved in two ways: by using abstract components or by exploiting prototypes.

The abstract component is a generic category that can be used in place of any other component type or implementation without having to specify a runtime category. A model with an abstract component cannot be instantiated, however they are extremely useful to define the initial conceptual description of the system during an iterating design process, or architecture templates and patters that can be used as reference libraries by designers. The prototypes act as placeholders for classifiers and they can be referenced anywhere a classifier would normally be referenced. The actual classifier can be specified later when referencing the parametrised component, \eg, when extending the classifier or when declaring a subcomponent. Prototypes are useful to create reference architectures or configurable product line families by providing, essentially, a parametrised classifier template that a designer can easily specify while following the structure already provided. An example is the data type exchanged between two components; the template of the component define the existence of the communication channel, but it uses a prototype for the actual type of the data. Because of the prototype, the designer needs to define a data type in order to be able to instantiate the model, but there is no restriction of the original definition of the template.

AADL is a formal declarative language described by a context-free syntax. This well-defined semantics is a key aspect of the language and a strong advantage, especially for quantitative system architectural analysis. Textual AADL is the main, more straightforward and detailed way to interact with the language, however, there are standard graphical representation that correspond to the textual definition. During the design of an AADL model, either of both representation can be used, a good strategy is to first define the skeleton of the model graphically, and then finalise the description using textual AADL. This process is supported by the Open Source AADL Tool Environment (OSATE), in this development environment a designer can easily switch between one representation of the language and the other, and any modification is propagated in all representations.

In the reminder of this section, we present more in details the component categories of AADL relevant to our work. We provide a description of the logical meaning of each category and their interactions, to better justify how used them to model a robotic architecture.

\subsection{Software components}
These categories are used to model the executable architecture of the system, they encompass functional units as processes, execution path as thread or thread groups and executable code such as functions, procedures and libraries as subprograms and subprograms groups. Moreover, the data category can be used to represent the application software artefact, some examples are data types, configuration files, internal data structures and communication messages. In addition to the semantic provided by the category itself, additional information associated to runtime (\eg, dispatch protocol and frequency of a thread) and non-runtime (\eg, source code associated to a specific subprogram) can be specified using properties.

\paragraph{Process} They represent an encapsulated execution unit; the address space, the persistent state and all internal resources are all protected and they are not accessible by external elements directly. 

\paragraph{Thread} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin scelerisque semper mi, a semper tellus condimentum eget. Maecenas rutrum ut odio et efficitur. Phasellus tincidunt lobortis augue eget aliquam. Integer ligula nibh, euismod tempus ullamcorper in, euismod sed lorem. Ut viverra tincidunt dapibus. Sed commodo nibh egestas leo mattis semper in a nulla. Sed porta dictum interdum. 

\paragraph{Thread group} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin scelerisque semper mi, a semper tellus condimentum eget. Maecenas rutrum ut odio et efficitur. Phasellus tincidunt lobortis augue eget aliquam. Integer ligula nibh, euismod tempus ullamcorper in, euismod sed lorem. Ut viverra tincidunt dapibus. Sed commodo nibh egestas leo mattis semper in a nulla. Sed porta dictum interdum. 


\subsection{Hardware components}
Lorem ipsum

\subsection{Properties}
Lorem ipsum

\section{AADL for robotics}
General introduction on why AADL is suitable for robotics

\subsection{Component-and-connector structure}
Lorem ipsum

\subsection{Robot operating system}
Lorem ipsum

\subsection{ROS templates}
Could be an independent subsection or part of the previous one

\section{Data Modelling}
Lorem ipsum

\subsection{ASN.1}
Lorem ipsum

\subsection{JSON}
Lorem ipsum

\subsection{JSON schema}
Lorem ipsum

%*****************************************
