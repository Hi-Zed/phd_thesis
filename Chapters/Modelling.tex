%************************************************
\chapter[Modelling]{Modelling}\label{ch:Modelling}
%************************************************

\begin{flushright}{\slshape The sciences do not try to explain, they hardly even try to interpret, they mainly make models. By a model is meant a mathematical construct which, with the addition of certain verbal interpretations, describes observed phenomena.} \\ \medskip
    --- John  von Neumann
\end{flushright}

As said by John von Neumann, science is about making models. They can be used to simplify a phenomenon and make it easier to define and understand; additionally, a model can be used to quantify or visualise reality. Knowledge extracted by the process of modelling can be reused to create a simulation of the system under analysis. For all these reasons, and because it is one of the most innate abilities of humans, modelling has always been the cornerstone of science, engineering and arts.

Modelling in engineering is an essential tool for design, analysis and simulation, models have different characteristics and take various shapes. A collection of mathematical formulas can be used to describe a physical phenomenon (\eg, friction between the ground and the wheels), or the behaviour of a system (\eg, a control system). Differently, a flow chart is a graphical model of an execution process, while pseudo-code is a textual one. A 3D model captures the physical shape of an object and can be used to study the design or space occupancy.

This chapter focuses on all the analysis, considerations, and models that we developed to create an appropriate environment for the \textit{system designer} to be able to represent a robotic architecture at different levels of detail. First, we introduce the \textit{component-connector} paradigm, its basic concepts, and why it is used in robotics. From there, we move to the AADL representation of the paradigm, and an extension to cover first a ROS node and later a complete architecture. To conclude the description of modelling a robotic system, we introduce a series of templates to simplify the modelling process. Lastly, since AADL is not a data modelling language, we present two approaches based on Abstract Syntax Notation One (ASN.1) and JavaScript Object Notation (JSON) to model the data exchanged in the system (\ie, ROS messages) and the internal state of each component.

%This chapter presents various modelling techniques that we used to describe multiple aspects of the architecture of a robot. 

\minitoc
\newpage

\section[The component-connector paradigm]{The component-connector \\paradigm}
\label{sec:cnc}
In robotics, the most popular middleware and frameworks are based on a \textit{component-connector} paradigm~\cite{shakhimardanov2010component}, and while different approaches implement it in different ways, the underlying structure is the same. In ROS, it is the computation graph, a peer-to-peer network of processes managing and exchanging data. Here, following the terminology of graphs, the components are called nodes, while asynchronous topics or synchronous services represent the connections; in both cases, the communication happens by exchanging messages. In SmartSoft, the underlying technological approach of the SmartMDSD toolchain, the structure is based on components, communication patterns and communication objects. Components communicate through four possible patterns: two synchronous, based on a client/server paradigm (\ie, send and query), and two asynchronous, based on a publisher/subscriber paradigm (\ie, push and event). All the patterns communicate using communication objects.

Another example is the Robot Construction Kit (RoCK), based on the component model of the OROCOS Real-Time Toolkit (RTT). In RoCK, and consequentially in OROCOS, the architecture is, again, based on components connected through ports. One last example is the OpenRTM-aist middleware developed by the Japanese National Institute of Advanced Industrial Science and Technology. They fully embraced the component-based approach, where multiple subsystems compose a robot, and each of them is a collection of components. Components communicate using connections established between predefined ports.

The popularity of the \textit{component-connector} paradigm is not coincidental. In their structure, robots are a system of systems, a hierarchical collection of components interconnected to create a working apparatus. Physically, a robot is a collection of sensors and actuators; same goes for the behaviour, simple low-level independent functionalities are not enough to implement even the simplest robot. Given all these needs, the most natural approach is to decompose the system in different and simpler subsystems and to simplify and characterise their interactions by the use of interfaces; the result is a \textit{component-connector} paradigm.

This work aims to provide a general and flexible representation that can be used to model an architecture that captures the design of a robot and it is compatible, at least at a higher level of specification, with multiple middleware and frameworks. To do so, we defined some common design patterns often used when creating robotic architectures. As already mentioned, the first key design approach is the use of components and connections, but, of course, this is a very high-level description, and it is only useful to define the topology. To better define an architecture without including technological details (\ie, specify a middleware or framework), we have to define a general description for component functionalities, and we have to specify the nature of each connection. By analysing the existing solutions for robotics (\ie, ROS, SmartSoft and OROCOS/RoCK), we identified four possible component behaviours that can exist (and coexist) in a component.

\paragraph{Source} A component expresses a \textit{source} behaviour when it is a generator of data or events. An example is a simple ROS node implementing a publisher: it generates messages and circulates them in the runtime graph. In SmartSoft there are two communication patterns that, implemented in a component, evoke this behaviour: push, to generate messages and send them to other components, and event, a data-less communication to trigger action in other components. This type of behaviour is used for device drivers since they create and circulate a digital version of the analogue input they detect. Coordinator components also use it since they are in charge of initiating high-level functionalities by generating an event or a specific message.

\paragraph{Sink} A \textit{sink} is a component that consumes data or events. In ROS, a node is a sink when it implements a subscriber that receives, processes, and consumes messages. The counterpart in SmartSoft is, again, a component that implements the same two communication patterns (\ie, push and event), but this time it is on the receiving side of messages and events. Component controlling actuators implement this type of behaviour since they receive commands from other components and consume them to operate a physical device. Alternatively, it is used by loggers since they simply collect all possible messages and store them. Lastly, any component activated by an event implements a corresponding \textit{sink} to receive and manage the trigger.

\paragraph{Filter} The most common behaviour for a component is the \textit{filter}. This type of component receives messages or events as input and processes or relays them to create an output. To describe more precisely the internal functioning of this behaviour, we have to distinguish two categories: without or with memory. 

In the former, the component does not store in any way the data received since they are processed and directly re-circulated in the system. This approach is common when doing simple conversions (\eg, change the unit of measurement or the coordinate system) or when it is necessary to resample the data (\eg, change the frequency or zero-pad the messages). In ROS, it is implemented by processing the received message directly in the subscriber callback and publish it before leaving the callback environment. The latter behaves similarly to a combination of a \textit{sink} and a \textit{source}; messages or events are received by the component and stored locally, then, at a later time, recalled from memory, processed and relayed in the system. This approach is used when doing more complex processing, for example when multiple messages need to be processed at the same time (\eg, smoothing a velocity set-point), or when multiple inputs need to converge in a single output (\eg, combining multiple laser rangefinder measurements in a single one). In ROS, this happens when messages are processed in a callback but not completely discarded at the end, and later, in the main loop or a different callback, they are processed and circulated back in the graph.

\paragraph{Reactive} A component has a \textit{reactive} behaviour when its functionalities are synchronously triggered by a message or an event, and it is usually implemented by using a remote function call. In ROS, this kind of behaviour is exemplified by services; they offer a public interface that can be called by external components and react with synchronous execution of a function that may return a value.  SmartSoft implements a similar synchronous system, but differentiate between one-way communications with no answer (\ie, send and forget) and two-way communications with a specific response. This behaviour is used to delegate to a central component a specific functionality (\eg, centralised conversion system), to activate a remote functionality (\eg, component \mbox{re-initialisation}), or to guarantee a timely answer to a request (\eg, soft real-time functionalities).

Implicitly, by describing the possible behaviours of a component, we already outlined the nature of the messages exchanged: a connection can be data-based or event-based. In a data-based connection, messages with specific content are exchanged between components. Usually, a specific communication channel only supports a pre-defined data format, but, in theory, a data-based connection can avoid the specification of the message exchanged. Each middleware or framework uses a different language to describe data format. For example, both ROS  and SmartSoft use a domain-specific language to define communication objects. This is the source of a substantial and unnecessary fragmentation because, in the end, all middleware and frameworks rely on basic data types and data structures, that are already covered by numerous standard data description languages. Event-based connections fall on the opposite side of the spectrum since there is no data exchanged: the critical element is the communication itself. The receiver only needs to detect an active connection to collect the event generated by the sender. In practices, it is common to implement event-based communications as data-based communication carrying an empty message. This is the approach used by ROS, since it does not support any pure event-only communication, but any communication channel (\ie, topics and services) supports standard empty messages. In SmartSoft, event-based communication is supported only paired with a publish/subscribe paradigm, since the \textit{Event} communication pattern is asynchronous.

To complete the description of an architecture based on the \textit{component-connector} paradigm, we need to analyse the cardinality of the connections. There are four different cardinalities:
\begin{itemize}
\item \textit{1-1}, this is an exclusive connection where the source is directly connected to exactly one destination.
\item \textit{1-n}, in this type of connection the stream of messages or events generated by a single source can be connected to one or multiple destinations.
\item \textit{n-1}, to achieve this configuration, multiple sources need to converge in a single destination.
\item \textit{n-n}, this is the most permissive of all cardinalities. In this configuration, there is no limit in the number of sources and destinations for a single communication channel. By using local policy, it is possible to implement all the previous ones, but when the communication is \textit{n-n} by design, it is impossible to guarantee other cardinalities. The result is a very flexible yet unpredictable connection.
\end{itemize}
In practice, robotic middleware and frameworks, rarely implement all four options. In ROS, topics are implemented as pure \textit{n-n} communication channels, since they follow a \textit{publish-and-forget} paradigm. Any number of publishers can publish messages on a topic, and each subscriber receives a copy of the message. There is no ownership of messages after they are published on a topic. While the communication supports a full \textit{n-n} cardinality, in practice, it is never used as such, but always as multiple publishers and a single subscriber (\ie, \textit{n-1}) or a single publisher and multiple subscribers (\ie, \textit{1-n}). ROS services are inherently \textit{n-1} since only a single server can provide a specific service, while multiple clients can request it. SmartSoft is more strict in the definition of the cardinality of its communication patterns: all the patterns with a publish/subscribe structure (\ie, push and event) have a \textit{1-n} cardinality, all the patterns following a client/server approach (\ie, query and send) support only a \textit{n-1} cardinality.

\section{AADL for robotics}
\label{sec:aadl-robot}
The Architecture Analysis \& Design Language was originally developed in the field of avionics, and then it was redesigned to target embedded real-time systems. Therefore, never in its history, the language was specifically designed for robotics. However, many parallels exist between embedded and robotics systems, consequentially, characteristics that were designed for the former are more than suitable for the latter.

Moreover, a general design approach means the language is not bound to a specific field, and the existing methodologies and technologies did not condition its design. Its agnostic nature makes AADL an excellent choice to provide a general modelling language for robotic systems, different middleware and frameworks sharing similar design principles can be represented easily with a common language. Additionally, AADL formal syntax and expressiveness guarantee consistency in the models and reduce the necessity to introduce extensions and ad hoc modifications, and even when this is necessary, the language itself regulates them.

As described in Section~\ref{sec:AADL}, AADL provides modelling tools for both hardware and software components. This is expected from a modelling language designed for embedded systems, where the development of the software is tied to the hardware; however, this characteristic is beneficial for robotics, too. Thanks to the abstraction provided by component-based middleware, modern robotic systems are not tightly connected to the underlying hardware platform as they used to be; today an obstacle avoidance system does not need to know precisely the data format of the measurements provided by the laser rangefinder to work correctly. However, this is true only for the development of single components or compartmentalised set of components, when designing the whole system or during execution, it is necessary to consider the behaviour of both hardware and software. 

\textit{How many and which sensors the robot uses to localise itself? Is there a teleoperation system? How much time does it take for a measurement to propagate in the system? How many critical functionalities are interrupted by a faulty sensor or actuator?} All these critical questions have to be answered during the design phase of the system, and this can be done by correctly modelling the hardware (sensors, actuators, connections, execution platforms, \etc), the software (drivers, low-level interfaces, functionalities, \etc), and their interactions.

In AADL, a designer can use properties to characterise components. Some examples are memory size, processors computational power, processes resource consumption, or connection throughput. These properties can be used to analyse the system before implementation or deployment. One of the tools provided by AADL is the concept of flow, they are a logical path through the architecture, and they are specified from input to output of a component. These flows can go through any feature (\ie, ports, accesses, groups and abstracts) and can represent any logical pathway (\eg, data, control, fault event, \etc). When modelling a flow, it is necessary to specify the source, the sink and the complete path of the flow; however, the definition can be done at system-level, it is not necessary to specify the behaviour inside the components. From this specification, it is possible to do end-to-end analysis, for example, identify the component involved in critical communications, estimate error propagation, calculate the time necessary for a measurement to impact on the behaviour of an actuator. The propagation time of messages and latency are fundamental in hard real-time applications, but even soft real-time applications can benefit from strict performance analysis. For example, a high-speed delta robot needs to consider communication latency to operate with high precision. In an autonomous wheelchair, the control system does not need high reactivity, but a correct latency estimation  will make the difference between a sudden braking and a gentle slow down when faced with an unexpected obstacle.

On a more technological level, the detailed description of components, their interactions, their structure and hierarchy provided by AADL is instrumental in solving some inherent problems of robotic middleware. For example, if we consider ROS, there is a total absence of an architectural view of the system. A partial representation of the interactions of the components is available at runtime by using tools like \texttt{rqt\_graph}, but this representation only considers topics and does not reflect the full structure of the system. Something similar can be achieved during deployment by using launch files, but while they are useful to organise the runtime of the components, there is no way to visualise the interactions between them, and they do not capture the internal connections. Both this limitations can be solved by using AADL, a complete model of the architecture provides a view of the system since its inception, and by using the \textit{system} component is possible to recreate the same hierarchy provided by launch files.

Even when considering middleware more focused on a model-based approach, AADL can bring a great advantage. In the SmartMDSD toolchain, architectures are designed using a custom meta-model defined via the Eclipse Modelling Framework. An approach that limits the design process to a particular environment and tightly connects the design phase with the implementation phase since the model reflects exactly some specific software artefacts. Moreover, while quite complete, the SmartMDSD meta-model, do not consider the hardware components as part of the architecture; therefore, any analysis related to the hardware has to be done with additional tools. In this case, AADL could be used as a general high-level modelling language compatible with the SmartMDSD meta-model, to be then transformed in an intermediate representation compatible with the existing code generators. The AADL version of the model could be used to perform analysis and to speculate on the possibility of using different technologies to implement different components or to deploy the same design on different platforms.

While not strictly related to robotics, an important feature of the language is the active community and the available tools. The Open Source AADL Tool Environment (OSATE)~\cite{feiler2004open} is a development environment not only to design AADL models both graphically and textually but also to exploit all the validation and analysis capabilities of the language. Some examples are end-to-end latency analysis, port connections consistency checks, computer resources budget analysis. Moreover, OSATE acts as an interface for the capabilities provided by Ocarina~\cite{hugues2008prototype}, an AADL model processor that supports parsing, code generation and model checking. Ocarina uses a front end/back end paradigm, where the front end is the AADL parser, and a back end can be any code generator that goes from the intermediate representation provided by the front end to executable code. Ocarina already supports various targets for code generation, none of these is a robotic middleware, however, thanks to the front end/back end paradigm, we created a suitable code generator that goes from an AADL model to a complete ROS architecture. This code generation process will be described in details in Chapter~\ref{ch:code-gen}.

\subsection{Modelling the CC paradigm in AADL}
\label{sec:aadl-cnc}
AADL is the perfect candidate to describe architectures based on the \textit{component-connector} paradigm because the language design supports components and connections. AADL components, at any level (\eg, system, process, device, subprogram, \etc) support some form of feature (\ie, ports and accesses) to communicate and interact with other components. In the previous section we described all the elements useful to characterise the robotic components and their interactions (\ie, component behaviours, type and cardinality of connections), in this section we will describe how AADL can model the same concepts.

First of all, it is necessary to outline which AADL artefacts are necessary to model this kind of paradigm. As described in Section~\ref{sec:AADL}, the general top-level container is the \textit{system} category, one step below there are three possible software categories that could act as components: \textit{process}, \textit{data} and \textit{subprogram}. A collection of subprograms models libraries or sets of APIs, data as first-level subcomponents model general storage or shared resources, processes are used to describe an enclosed execution space and can exist only as direct subcomponents of a system. Therefore, it is clear that the perfect candidate to model components is the \textit{process} category. Since the process execution space is directly accessible only by its subcomponents, the category supports all available AADL features (\ie, interfaces).

In the previous section we introduced data and event-based communications, AADL supports both of them thanks to the additional type specifier when defining a feature, it can be a \textit{data port}, an \textit{event port} or an \textit{event data port}. Moreover, ports can have a specific data type, defined using a \textit{data} category; this is useful to model the type of message exchanged in the connection. In AADL, all ports have natively a \textit{n-n} cardinality, except for the \textit{input data port}; since this type of port models a communication with no queue, it does not support multiple incoming connections; however, they are supported by the \textit{input event data port} since it includes a queue in its model. In the base language, there is no way of restricting the cardinality of ports, but it is possible to define new properties to specify a connection better and, eventually, indicate its cardinality.

To model component behaviours, we go a step further in the component hierarchy and consider process subcomponents. Again, the \textit{data} and \textit{subprogram} categories are not relevant for the behaviour since they are used to define memory and subroutines. The third and more suitable candidate is the \textit{thread} category. They represent an execution path through code, and their behaviour is periodic with various characteristics or triggered by an external input (\eg, incoming data or events). Moreover, multiple threads can coexist in the same process and, potentially, execute in parallel. All these characteristics make the thread a suitable category to model component behaviours. However, as we described in the previous section, each behaviour is related to a specific external interaction, we achieve this by combining threads and ports.

\paragraph{Source} In this behaviour, the components generates messages or events. Therefore the thread needs an output port that can be of type data or event. Since there is no external source triggering this behaviour, it is necessary to specify the scheduling of the thread, usually periodic.
\paragraph{Sink} In this case, the components receives and consumes messages or events. Given this, an input port needs to be modelled as an interface of the thread. By changing the type of the input port, it is possible to change how the sink behaves. A data port, combined with periodic scheduling, would model a sampler that receives a constant stream of data, an event data port would define the subscriber of a publish/subscribe paradigm, an event port defines a sink managing external triggers.
\paragraph{Filter with memory} For this type of behaviour it is necessary to add the extra memory element, in AADL all memory, on a software level, is modelled using the \textit{data} category. Therefore, to completely model this type of filter, it is necessary to define a data component inside the process that acts as a shared memory between two threads, one with an input port (\ie, sink equivalent) and one with an output port (\ie, source equivalent).
\paragraph{Filter without memory} This type of filter is more straightforward to model since there are few elements. All processing happens directly in the thread that receives the message, and the same thread is responsible for circulating it back in the architecture. Given this, this behaviour is modelled using a single thread with an input port of any kind and a corresponding output port.
\paragraph{Reactive} This behaviour represents a synchronous remote execution similar to a remote function call. In AADL there are various approaches to model an RFC, to keep the structure more in line with the other behaviours the best option is to pair a thread with a remote subprogram call. It is done by defining a \textit{subprogram} as a thread subcomponent and, on the frontier, declare an access bound to that specific subprogram.

\begin{landscape}
	\begin{figure}[t]
	\centering
	\includegraphics[height=0.88\textwidth]{gfx/arch_figures-25}
	\caption[Simplified graphical AADL modelling a basic architecture.]{Simplified graphical AADL modelling a basic architecture. Highlighted in green the data component used for interactions between threads.}
	\label{fig:cnc-arch}
	\end{figure}
\end{landscape}

\subsection{A basic example}
\label{sec:cnc-basic}
With the paradigm described in Section~\ref{sec:cnc} and the tool provided by AADL presented in Section~\ref{sec:aadl-cnc}, it is possible to define a basic architecture, not only the topology of the connections but also the internal functioning of the components. As an example, let us take the architecture defined in Figure~\ref{fig:cnc-arch}; in this simple architecture, we want to model a robot with two control functionalities: line following and teleoperation.

In the top branch of the architecture, we have the line following subsystem: a sensor driver that generates measurements indicating the presence of a black line on the ground and a simple component that directly translates the sensor input in a velocity command. The former expresses a \textit{source} behaviour, it generates messages and circulates them in the system, it is modelled by a process containing a periodic thread, on the frontier, there is an output data port. The latter has a \textit{filter} behaviour, it has two ports on its frontier: one input event data port, to queue the messages and trigger a component functionality, and one output data port, to send to the next component the velocity commands. In this example, the line following component is straightforward and can estimate a set-point directly from the sensor measurements. The component does not need to store any information: it is a filter without memory. The internal model of the components is a single thread with an input and an output port, both directly connected to their corresponding ports on the process frontier.

On the bottom branch, there is the teleoperation subsystem: a joypad driver providing readings of the input and a teleoperation component to convert the joypad input in set-points. Similarly, as the other branch, the driver expresses a \textit{source} behaviour, it converts the input coming from the joypad in messages compatible with the architecture. The teleoperation component, however, does not have the same \textit{filter} behaviour of the line follower, since it stores the incoming messages to smooth the set-point: it is a filter with memory. Two ports defined on the process frontier characterise this model: one input event data port and one output data port. Internally, these two ports are connected to two different threads. The event data port triggers a thread that receives the messages and stores them locally. The output data port is connected to a periodic thread, on fixed intervals, it reads the two most recent messages and estimates a single set-point compatible with the robot acceleration. Each thread has its data access to write or read on the shared memory area, modelled as a data component.

In the middle of the architecture, to mediate between the two different control systems, there is a multiplexer component. This is an example of multiple behaviours coexisting in the same component: there are two filters, one for each input, and a \textit{reactive} behaviour. Each of the filters relays the correct message to the output, and only one of them is active at a given time. The remote function call of the \textit{reactive} behaviour triggers the selection of the active input between the two available (\ie, line following or teleoperation). This component models four different features on its frontier: two input event data port, they are the receiving side of the two filters, one output data port, it selectively relays the selected input, and one subprogram access, to trigger the reactive behaviour. Internally, each input port is connected to and triggers an independent thread, which receives the inputs and stores them in a shared memory area. The output port is connected to a periodic thread, which reads the content of the inputs from the shared memory and publishes the correct one. The subprogram access interfaces with a thread which has the corresponding subprogram as a subcomponent, this thread is triggered by an external call on the access and changes the currently selected input. All the threads have a data access to the same data component representing the shared memory area.

The last element of the architecture is the control component. It is directly connected to the hardware of the robot and consumes the set-point provided by the multiplexer to operate the motors; in summary, it expresses a \textit{sink} behaviour. It is modelled by a process containing a single thread, which is connected and activated by the event data port defined on the frontier of the component.

\begin{figure}[t]
    \myfloatalign
    \subfloat[1-1]
    {\includegraphics[width=.45\textwidth]{gfx/conn/11}} \quad
    \subfloat[1-n]
    {\includegraphics[width=.45\textwidth]{gfx/conn/1n}} \\
    \subfloat[n-1]
    {\includegraphics[width=.45\textwidth]{gfx/conn/n1}} \quad
    \subfloat[n-n]
    {\includegraphics[width=.45\textwidth]{gfx/conn/nn}}
    \caption{Mapping between ROS topics and AADL connections.}\label{fig:connections}
\end{figure}

\section{From CC to ROS}
\label{sec:cnc-ros}
In Section~\ref{sec:cnc} we already highlighted parallels between the \textit{com\-po\-nent-connector} paradigm and ROS. At first, it may seem the architectural model of ROS is more complex than a simple component-based approach, since, together with the nodes, there is the extra element of topics, apparently, an independent and additional factor. However, topics are nothing more than an agreed name to establish a connection between nodes, they are defined and treated as existing entities in the runtime graph, but they do not mediate any communication. After two nodes agree, through the mediation of the ROS master, on a communication channel (\ie, a topic), any consequential exchange of messages happens on a direct connection between the two nodes. This means a topic is an aggregation of point-to-point connections and not an independent component mediating the communications. 

Given the actual nature of nodes and topics, it is possible to say that ROS completely follows a \textit{component-connector} paradigm, where the nodes are the components, and the topics are an aggregation of one or multiple connectors sharing the same characteristics. Figure~\ref{fig:connections} illustrates how all the possible topic configurations (\ie, \textit{1-1}, \textit{n-1}, \textit{1-n} and \textit{n-n}) can be translated in an AADL-based representation, assuming that all the output ports are data ports and all input ports are event data port. The reason for this choice is to model the behaviour of ROS publishers and subscribers. The former does not produce an event notification when it creates a message, but it just circulates them in the graph; hence, it is a simple data port. The latter is triggered by the arrival of new messages and supports queue, and for these reasons, it needs to be modelled as an event data port. As shown in the figure, the substitution process from a topic representation to a connection-based one is quite straightforward. First, we select a topic, and then we list all the publisher interacting with it, after removing the topic, we directly connect each publisher to all subscribers of the original topic. 

However, by doing this substitution process, one piece of fundamental information is lost. In AADL, each connection and each port requires a unique name, and this means that it is impossible to maintain the information that a specific connection is part of the aggregation defining the topic. An easy solution is to give the connections a recognisable name, for example, each connection for the topic \texttt{/chatter} can have a name starting with \texttt{chatter\_}, however, easy does not translate to good, since this approach is entirely unacceptable, it breaks the model by encoding information in variable names. A more elegant solution compatible with the features of AADL is to declare a new \textit{property set}, in this set, called \texttt{topic\_properties}, it is possible to define two new properties for connections and features. One property is the \textit{Default\_name}. It applies to ports and subprogram accesses, and it is used to specify the name of the topic (or service, for subprogram accesses) defined during the implementation of publishers and subscribers. The other property is \textit{Name}. It applies to connections and, at system level, it can be used characterise connections between processes as part of the same topic. The utility of this property is twofold, not only it captures the information of a connection belonging to a topic, but it can be used to include in the model dynamic renaming of topics typical of ROS.

When introducing the concept of component behaviours, we showed how each behaviour could be represented with a specific ROS functionality; however, this does not mean that the relationship is bidirectional. ROS imposes very few restrictions to the developer; therefore, while the external interface of a node follows the same behaviours presented in Section~\ref{sec:cnc}, the internal implementation may follow an arbitrary pattern. The basic implementation style of a ROS node is to have the main execution loop that periodically polls subscribers and services and pass them the execution every time a new request arrives, similarly to the \textit{component-connector} paradigm we presented, this execution happens in a separate environment; however, it is not independent and parallel, but sequential. Practically, this difference is not meaningful, the conceptual structure presented by the model is the same, and this is just an implementation detail. Nevertheless, it is worth to explore an implementation where the actual execution matches the description of the model completely; this will be discussed more in details in Section~\ref{sec:ros-node}.

In summary, \textit{sink} and \textit{reactive} behaviours are related to their counterpart in ROS by a bidirectional relationship. It is not possible to say the same when we consider \textit{source} and \textit{filter} behaviours. For reference, let us take the simplest ROS node with publisher functionalities presented in one of the basic ROS tutorial\footnote{http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber(c++)}. In this example, it is possible to see how it is common practice to define a single execution path where everything (\eg, initialisation, polling, publishing, \etc) happens. This approach is sustainable for small implementations and node with simple behaviours, but it is not suitable for more complex components. This is especially true when implementing components that express multiple \textit{filter} with memory behaviours, in this cases to ensure maintainability, flexibility and understandability of the design it is necessary to follow an approach more in line with the \textit{component-connector} paradigm, where an independent execution path manages each different input and output. In summary, given the flexibility of the ROS middleware, it is not possible to guarantee that all the implemented node will follow, internally, the design of the \textit{component-connector} paradigm. However, this work aims to provide a general modelling approach that can be used to enhance the existing design practices for robotic software; therefore, we will present a way to model (see Section~\ref{sec:ros-in-aadl}) and implement (see Section~\ref{sec:ros-node}) ROS nodes following a simpler, more flexible, easier to maintain and more robust design aligned with the \textit{component-connector} paradigm.

While describing the relationship between component behaviours and ROS node implementations, we introduced a vital element of any robotic component: the main execution loop. It is in charge of multiple critical tasks of the component; some examples are initialisation, management of incoming requests, dynamic reconfiguration (when supported), error management, shutdown and clean-up procedures. Its role is crucial, but it is often left out in the modelling phase because of its inherent nature (often hidden by the framework) as the backbone of the component. Nevertheless, it is imperative to include it in the modelling process because some of its tasks may need to be specialised by the developer (\eg, initialisation, error management, \etc). In ROS, in particular, given the freedom left to the developer, it is critical to model the main execution loop to highlight the different functionalities of the nodes, since, as described before, they are often merged in a single execution path. This is another case where for the sake of creating a more general approach and enhancing the ROS design of nodes we, with our modelling approach, overrode the flexibility of ROS to make the main loop an independent execution path disconnected for any other functionality-related path. In summary, in our model, each ROS node, independently from its behaviour, has an additional thread that manages the core functionalities of the component.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.95\textwidth]{gfx/essential}
    \caption{Graphical AADL modelling the base structure of the enhanced ROS component.}\label{fig:essential}
\end{figure}

\subsection{Modelling a ROS enhanced component in AADL}
\label{sec:ros-in-aadl}
In the previous sections, we introduced all the elements we need to model a ROS node: the \textit{component-connector} paradigm, how it applies to ROS and the missing elements to bridge from a conceptual model to technological design, and the corresponding AADL description. In this section, we provide a full description of a ROS enhanced component, providing first a model of an essential (\ie, no component behaviours) component and then modelling additional functionalities.

Figure~\ref{fig:essential} provides a graphical representation of the base structure of the enhanced ROS component. At first glance, it is clear that the model captures more information than what we described until now. The component contains a state machine that is triggered by multiple event ports, various internal functionalities detail the main execution path, there is a permanent internal state, and two new features appears on the frontier of the component. Let us analyse the model in order by starting from the state machine: it is used to model the internal life cycle of the component. In ROS, there is no defined evolution of the status of a node, and, usually, it can be in only two different states: not executing and active. Moreover, the only way to check the current status is to trigger one of the functionalities of the node (\eg, read a topic). However, it is common in component-based approaches to define a definite life cycle of the component. Additionally, other robotic middleware and frameworks have an established evolution of the status of their components (\eg, SmartSoft and OROCOS), therefore, modelling the internal state machine is a requirement to guarantee the generality of our approach. Our life cycle follows a structure with four different states.

\paragraph{Init} Initial state of the life cycle, all the initialisation procedures happen here. The transition from this state guarantees the component is ready to execute all its functionalities. From \textit{init} the component can transition to \textit{running}, when all the initialisation procedure are completed successfully, \textit{error}, or \textit{closing}.
\paragraph{Running} Normal operational state of the component. In this state, all the main functionalities are active, and the component is working with no issues. The possible transition are: to \textit{running}, the state machine periodically triggers a self loop to ensure that the component is alive and functional, to \textit{error},  or to \textit{closing}.
\paragraph{Error} The component transitions in this state when it captures known errors. While in this state the component is not in execution and recovery procedure can be activated to transition back to an active state (\ie, \textit{init} and \textit{running}), or if the error is unmanageable or catastrophic, to transition to the \textit{closing} state.
\paragraph{Closing} Final state of the life cycle, all the cleanup and shut down procedure happens in this state. The transition to this state is triggered by any shutdown signal (internal or external), or when the nodes encounter a catastrophic error that cannot be recovered and requires the node to shut down.
\medskip

Event ports on the main execution path of the component and the external frontier trigger the transition in the state machine. The event port on the frontier models any external signal used to force the shutdown of the node (\eg, SIGINT signal), it triggers the transition to the \textit{closing} state from all active states. All the ports on the main execution thread represent the normal evolution of the system and are activated every time one of the execution phases of the component finishes or after an error.

The main execution path of the component is modelled using a periodic thread called \textit{main\_thread}. The thread has four subprograms, and they represent the active functionalities during each phase of the life cycle. AADL can enforce this relationship since for each state it is possible to specify which subcomponent is active, therefore, while the \textit{main\_thread} is always enabled, only one of its subprograms is active at any given time. Since each subprogram is in charge of a specific state, they are all connected to their corresponding event port to trigger a transition to the next state. Each subprogram has a specific functionality.

\paragraph{Prepare} It is active in the \textit{init} state. This subprogram is in charge of managing node initialisation; it sets parameters, initialises variables, sets up publishers and subscribers, and any other node-specific initialisation activity. It is connected to the \textit{run} and \textit{error} event ports, to trigger the two possible transitions related with a successful or unsuccessful initialisation.
\paragraph{Spin} It is active in the \textit{running} state, and here the ROS spinner is implemented. When this subprogram is active, the \textit{main\_thread} acts as a coordinator of node behaviours, it checks for incoming events and handles potential errors. Two event ports are controlled by this subprograms: \textit{run}, to trigger the self-transition, \textit{error}, to transition to the \textit{error} state when necessary.
\paragraph{Error\_handler} It is active in the \textit{error} state. Here are implemented all the functionalities to deal with known errors of the component, for example, an incorrect initialisation or a malformed message. From the \textit{error} state it is possible to transition to any other state, as a result this subprogram is connected to the \textit{run}, \textit{error}, and \textit{init} ports.
\paragraph{Tear\_down} It is active in the \textit{closing} state. This subprogram implements all the procedures related to node shut down. For example, in some cases, a node may need to notify another before shutting down, or it needs to disconnect from a physical device gracefully. Since this is the final state of the life cycle, this subprogram is connected to no event port on the thread frontier, even so, the corresponding port on the subprogram is still modelled for flexibility and potential future extensions.
\medskip

As a final note on the node life cycle, we have included in the model of this essential node a \textit{requires subprogram access} on the frontier of the \textit{main\_thread} which is connected to its counterpart on the process. This access models a remote function call to notify an external supervisor about the current state of the node and any transition. In this way, not only the component has a clear life cycle that defines the execution phases, but it is possible to monitor the evolution of the status through time and keep track of any unexpected behaviour.

The last element to cover is the \textit{internal\_state}: a data component used to model the execution memory of the component. In Section~\ref{sec:cnc}, we described how not all the component behaviours requires a shared memory area; therefore, it should not be necessary to include a data component in an essential node. However, in practice, only the simplest component does not require a persistent internal state because this shared memory area does not exist only as a way for different threads to exchange information. It stores configuration parameters, error mappings, information for shutdown procedures, \etc. For these reasons, not only it is present in this minimal node but is directly accessible by all subprograms in the \textit{main\_thread}. Since AADL is not a data modelling language (see Section~\ref{sec:AADL}), we will not detail here the inner structure of the \textit{internal\_state}, this topic will be covered in Section~\ref{sec:data}.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.95\textwidth]{gfx/sample_node}
    \caption[Graphical AADL modelling a complete ROS node.]{Graphical AADL modelling a complete ROS node. The design includes two subscribers and two publishers.}\label{fig:sample-node}
\end{figure}

After modelling an essential node, and by using it as a starting point, we can now add behaviours and functionalities. Figure~\ref{fig:sample-node} shows a graphical representation of a more complex node expressing two coexisting behaviours: a \textit{filter} with memory, modelled with a combination of a \textit{callback} and a \textit{publisher}, and a \textit{filter} with no memory, defined with a subscriber and a publisher in the same thread and identified by the name \textit{callback\_pub}. As introduced in Section~\ref{sec:cnc-ros}, behaviours are modelled using a combination of thread and corresponding ports. In the figure it possible to see how each thread is characterised by a specific port that evokes its functionality: the \textit{callback} has an input event data port, to receive messages and manage queues, the \textit{publisher} has an output data port, to circulate messages to the rest of the architecture, and the \textit{callback\_pub} is a combination of both and has input and output ports. Each thread port is then connected to its counterpart on the process to relay messages between the inside and the outside component environment. What is not visible from the figure is the data components associated with each port. In AADL, it is possible to specify the data type exchanged on a connection, and the model will automatically verify that the ports are compatible. 

Listing~\ref{lst:message-example} shows a fragment of AADL code where data components associated with ROS messages are declared. Listing~\ref{lst:message-use-example} shows how the same messages are included and used to specify the data type of the ports of the node presented in Figure~\ref{fig:sample-node}. More details about ROS messages and their definition in the model will be discussed in Section~\ref{sec:data}.

\begin{lstlisting}[language=AADL,caption={Definition of ROS messages using AADL data components.},label=lst:message-example]
package std_msgs
public
	data String
		properties
			Source_Text => ("String.schema.json");
	end String;
end std_msgs;

package geometry_msgs
public
	data Pose
		properties
			Source_Text => ("Pose.asn");
	end Pose;
end geometry_msgs;
\end{lstlisting}

\begin{lstlisting}[language=AADL,caption={Use of AADL data component to specify the data type of a port.},label=lst:message-use-example]
package publisher_subscriber
public
	with std_msgs, geometry_msgs;

	process complex_node
		features
			callback_in: in event data port std_msgs::String;
			publisher_out: out data port std_msgs::String;
			callback_pub_in:  in event data port geometry_msgs::Pose;
			callback_pub_out: out data port geometry_msgs::Pose;
			close: in event port;
			notify_state: requires subprogram access state_manager;
	end complex_node;

end publisher_subscriber;
\end{lstlisting}

\subsection{Modelling ROS architectural elements in AADL}
\label{sec:ros-arch}
In Section~\ref{sec:aadl-robot}, we presented multiple reasons why AADL is a suitable language for robotics, one of them was the capability of the language to model both software and hardware components, however, in our descriptions on how to model ROS nodes we never mentioned any physical interface. The reason for this is that we followed a top-down approach to describe a robotic architecture, at a higher level of abstraction (\ie, in the \textit{component-connector} paradigm) there is no need to make a distinction between a software component and a hardware component. However, now that we are moving closer to the actual implementation, these characteristics of AADL will be integrated into our model. We will specify how hardware components can be integrated into the architecture and how to differentiate between communications happening on ROS topic and other physical communication channels. When describing models closer to the implementation level, we also encounter design solutions that are not captured at a more abstract and general level, in ROS there are three key design features that we decided to specifically model in our approach. First of all, existing packages and nodes, the greatest resource of ROS is its repository of already available components, and it is imperative to be able to model them correctly in an architecture. Second is \textit{tf}, the coordinates frame manager, backbone of various ROS nodes, therefore it is necessary to include it in the model. Last, \textit{actionlib}, an interface to start, monitor, pre-empt and cancel remote tasks, while it is not a commonly used design approach, it is a useful and elegant way to delegate and coordinate complex task between components.

\paragraph{Physical devices} AADL offers multiple hardware categories to model the physical aspects of a system. For elements like processors or memories, we will not go in details, since they work for robotic architectures in the same way of any other, it is possible to bound a software component (\eg, processes or data) to its physical counterpart (\eg, processor and memory) to specify the hardware implementation of the system. In ROS this feature of AADL can be used to model distributed architectures, by binding components to different physical platforms, the designer can specify where each node will be executed at runtime. This creates a deployment view of the system without the need of defining a different model; moreover, AADL analysis capabilities can be used to determine if a specific platform is suitable for a specific subset of the components (\eg, does the target computer has enough RAM to run the system?).

\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{gfx/mini_arch}
    \caption{Graphical AADL modelling a ROS-based teleoperation subsystem.}\label{fig:mini-arch}
\end{figure}

What is different in a robotic system is that sensors and actuators are an integral part of it, to model them, it is possible to use AADL devices. A \textit{device} represents an interface between the physical world and the architecture, it can be modelled as a simple interface or to include the inner functionalities and characteristics of the physical component (\eg, type of communication, computational power, data type).  Devices can connect to processes using ports or accesses. When modelling a ROS architecture, the fact that physical devices and software components communicate using the same interface rises the issue of differentiating between a topic-based connection and other types of connections; the solution comes in the shape of AADL physical and virtual buses. A \textit{virtual bus} can be used to model abstract communication channels, like ROS topics, while a \textit{bus} can be used for physical connections, like Ethernet and USB. Figure~\ref{fig:mini-arch} shows how this two categories, together with a device, can be used to model a simple joypad-based teleoperation subsystem where a physical bus called \textit{usb\_bus} is bound to the physical connection between the device modelling the joypad and its driver, and a virtual bus called \textit{ROS\_bus} is bound to all the connections representing topics.

\paragraph{Existing ROS nodes} ROS is currently the most popular and widespread robotic middleware, resulting in a very prolific and active community, which becomes one of its greatest resources. Given ROS component-based structure and popularity,  a multitude of already existing packages and nodes exist that a developer can simply download and include in his architecture. When creating a modelling approach for ROS, it is mandatory to include the possibility to model existing nodes, to do so we can exploit the dual representation based on component type and implementation provided by AADL.  Existing ROS packages are modelled directly as AADL packages while existing nodes are modelled using the component type only. We provide an interface that appears and behave in the same way as the already existing component, but we do not model in any way the internal functioning. In Figure~\ref{fig:mini-arch}, \textit{joy\_to\_cmd} is a custom made node, completely modelled as visible from the \textit{close} port and the \textit{notify\_state} subprogram access, on the contrary, \textit{joy\_node} is an existing node from the package \textit{joy}, here only topic related ports are modelled to provide an interface to the rest of the system. 

Listing~\ref{lst:legacy-nodes} shows the textual AADL used to model the legacy \textit{amcl} ROS package and the interface of the \textit{amcl} node. It is possible to see how the model descriptions follow the same naming conventions of the original package. The ROS package name corresponds to the AADL package, the process name to the node, and the topics name match the definition of ports and properties.

The only potential issue is to create all the models for the existing components, few possible solutions, when combined, can almost automatically generate them. First, analyse the existing nodes at runtime to detect which topics and which messages they use, additionally it is possible to do code inspection to list all the publisher and subscribers, lastly, most packages are documented on the ROS wiki\footnote{http://wiki.ros.org/joy} with, at least, the list and type of topics. Unfortunately, sometimes this is not enough, the joypad driver is one of those examples, to detect the connection automatically with the physical device is extremely difficult, at this point the only solution is the human intervention.

\bigskip

\begin{lstlisting}[language=AADL,caption={Auto-generated AADL to model the amcl package and the amcl node},label=lst:legacy-nodes]
-- Auto-generated process interfaces for amcl
-- Generated on: 17/11/2017 17:28:07
package amcl
public
with topic_properties, geometry_msgs, sensor_msgs, nav_msgs;
process amcl
	features
	amcl_pose: out data port geometry_msgs::PoseWithCovarianceStamped;
	particlecloud: out data port geometry_msgs::PoseArray;
	scan: in event data port sensor_msgs::LaserScan;
	map: in event data port nav_msgs::OccupancyGrid;
	initialpose: in event data port geometry_msgs::PoseWithCovarianceStamped;
	properties
	topic_properties::Default_Name => "/amcl_pose" applies to amcl_pose;
	topic_properties::Default_Name => "/particlecloud" applies to particlecloud;
	topic_properties::Default_Name => "/scan" applies to scan;
	topic_properties::Default_Name => "/map" applies to map;
	topic_properties::Default_Name => "/initialpose" applies to initialpose;
end amcl;
end amcl;	
\end{lstlisting}

\paragraph{tf} This package is one of the core functionalities of ROS, and it exists to help manage multiple coordinate frames and transformations over time. Differently from other ROS features, the access to \textit{tf} does not go through any established communication channel (\ie, topics or services), but by using a set of APIs that directly access the distributed coordinate system, additionally, there is no need to start a node to enable it. Therefore, disregarding how \textit{tf} is practically implemented in the system, we can describe it as a centralised resource where all the coordinate frames of the robot and their evolution in time are stored, and it is possible to read or update the content of this shared resource by using specialised APIs. With these assumptions, the best way to model \textit{tf} is to use a single data component at system level that all the nodes can access through data accesses when necessary. The single data component stores the description of the coordinate frames and their evolution in time, while the data accesses represent the bidirectional APIs.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.95\textwidth]{gfx/action}
    \caption{Graphical AADL modelling the ROS actions.}\label{fig:action}
\end{figure}

\paragraph{actionlib} Actions are an extension of ROS services, created to manage requests that are too computationally heavy for a traditional client/server approach. An action client triggers a remote execution, then resume normal functioning while waiting for a response, if needed. While an action is under execution, it sends periodic updates of its status, and the original caller can terminate it before it finishes. The actual implementation of ROS actions is based on topics that are used to trigger or cancel the execution, provide the result, and get updates on the status.
 
When implementing the action client and server in a ROS node, a developer uses two existing classes: \textit{SimpleActionServer} and \textit{SimpleActionClient}. These two classes act as an interface hiding the underlying topic-based system. In AADL, it is possible to do the same using a \textit{thread group}; as the name suggests, it is a subcomponent used to group threads together and organizes them. Fig.~\ref{fig:action} shows a graphical representation of how an action can be modelled. The client thread group has two outbound ports representing the \textit{goal} topic, used to activate the action, and the \textit{cancel} topic, used to cancel the action; these two ports have their corresponding version on the server group as inbound ports, this time used to trigger the callbacks. The group modelling the \textit{SimpleActionServer} has three outbound ports used to communicate with the client, and these ports have their equivalent on the client group. Modelling is about abstracting the underlying implementation and representing concepts, therefore at process level, the ports of the thread group are aggregated in a \textit{port group}; this maintains the conceptual representation of the action acting as a single communication channel.

\begin{landscape}
	\begin{figure}[t]
	\centering
	\includegraphics[height=0.88\textwidth]{gfx/arch_figures-15}
	\caption[Graphical AADL modelling a basic ROS architecture.]{Graphical AADL modelling a basic ROS architecture. Highlighted in green the internal state, in yellow the life cycle and in blue the main thread.}
	\label{fig:ros-arch}
	\end{figure}
\end{landscape}

\subsection{A ROS basic example}
In Section~\ref{sec:cnc-basic}, we presented how to model a simple architecture using AADL and following the \textit{component-connector} paradigm. In this section, we describe how that architecture can be updated to represent a complete ROS-based system. As visible for Figure~\ref{fig:ros-arch}, the functionalities of the architecture are the same: line following and teleoperation. However, in this version, we include ROS specific elements and model physical components of the system.

Let us start again from the top branch of the architecture: the line following subsystem. From a pure software point of view, the architecture is unchanged, it consists of two components, one expressing a \textit{source} behaviour and the other a \textit{filter} behaviour with no memory. The difference is in the internal representation of the components, now nodes, which is based on the essential node defined in Section~\ref{sec:ros-in-aadl}; it includes the main execution loop, the internal life cycle and the internal state. Both these nodes are assumed to have application-specific functionalities, therefore are fully modelled as custom nodes. From a hardware point of view, this subsystem now includes a physical device: the line detection sensor. It is modelled using an AADL device, and it has a physical connection with the driver component. The connection is modelled using an output data port on the device and the corresponding input data port on the process, to specify that it does not represent a ROS topic, it is bound to a physical bus that models a USB connection.

The bottom branch is similar to the example presented in Figure~\ref{fig:mini-arch}. On the software side, the teleoperation component is unchanged, but now it is modelled as a ROS node instead of a generic \textit{filter} with memory component, the driver component is replaced by the already existing \textit{joy\_node}; therefore, it is modelled only using the external interface. As for the line following subsystem, now the teleoperation subsystem includes the physical device; it models a USB joypad, and it is connected to the driver through a data port. Since this connection is a physical UBS connection, too, it is bound to the same physical bus as the connection between the line detector and its driver.

The multiplexer component is now a ROS node. A set of two subscribers now replaces the original \textit{filter} behaviour, they collect the messages coming from the two different subsystems, and one publisher, it relays the correct message to the control component. The \textit{reactive} behaviour is implemented using a ROS service. The functionality is the same: an external client can call this service to change the selected input from line following to teleoperation and vice versa.

The control component is now a control subsystem. In the previous version of the architecture, there was a single component expressing a \textit{sink} behaviour, now, the component is replaced by a custom ROS node with a subscriber to receive the set-points and a device modelling the electrical motor. In this case, the interaction between the driver and the motor goes through an Ethernet connection; therefore, we modelled a second bus component representing this type of connection.

The architecture includes a virtual bus representing ROS topics, all virtual connections (\ie, topics and services) are bound to this bus (not shown in the figure to avoid unnecessary clutter). While not visible using graphical AADL, the architecture includes data components for message types. Each type is represented by a data component in the same package as defined by the existing ROS hierarchy. The data type of a port is specified in the process definition, and connected ports must have the same data type.

\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{gfx/hierarchy}
    \caption{Hierarchical structure of the modelling templates.}\label{fig:template}
\end{figure}

\section{Modelling templates}
\label{sec:template}
Up until now, we built up a hierarchical model that goes from the most straightforward, robot independent, component-connector design, to a complete and full-fledge ROS-based architecture; however, we did not describe how the \textit{system designer} can use these approaches. This omission is voluntary because, while the results obtained are a powerful modelling framework, they do not come without complications. Assuming a designer is already familiar with AADL, the process of modelling a single architecture is quite tedious and prone to errors, especially replicate the same basic design for all ROS nodes. Moreover, this model aims to be a stepping stone for automatic code generation. For this reason, the structure of the model must be consistent. In summary, there are a few issues that need to be addressed to transition from a collection of models to a design tool:
\begin{enumerate*}[label={\alph*)}]
\item to make the modelling approach more accessible so that it can be a reasonable alternative to the current development process for ROS,
\item enforce the presented structure, without it being a burden to the design process,
\item to make the underlying structure self-explanatory, without the need for lengthy accompanied documentation.
\end{enumerate*}

Find a complete solution to all these issues is a challenging task. In small size projects, the process of modelling will always be more complex and time-consuming than direct development, until we achieve perfect code generators.  Moreover, we have to consider the trade-off between the flexibility and the number of modelled or implemented functionalities. Nevertheless, in an effort to solve these issues, we developed a series of modelling templates that the \textit{system desginer} can use to simplify the modelling process, to do so, we exploited the inheritance capabilities of AADL.

Figure~\ref{fig:template} shows the hierarchy of packages and components when modelling a ROS architecture. At the top of the hierarchy, there is the \textit{component-connector} paradigm. Here, the main elements of the paradigm are modelled: the component and its implementation, the shared memory area and the inner functionality of behaviours. As before, we used a hierarchical approach to model the threads of the behaviours. All behaviour interfaces inherit from the same parent thread, which implements the access to the shared memory area as the only common characteristic. Then they specify their port independently to characterise the type of behaviour, only the implementation of the common parent exists since the internal description is always the same (\ie, a single subprogram).

The ROS AADL package extends the \textit{component-connector} packages. Here all the necessary elements to model ROS nodes and architectures are defined. The ROS specific elements are modelled directly with no inheritance required: the data component representing \textit{tf}, the virtual bus bound to ROS communications, the main execution loop of the node, and the subprogram associated with the life cycle notification. All the other elements are inherited from the description of the \textit{component-connector} package: the node and its implementation extend the component definition, each thread interface extends the corresponding high level behaviour interface (\eg, \textit{service\_provider} extends \textit{reactive}, \textit{callback} extends \textit{sink}, \etc) while the thread implementation extends directly the behaviour implementation. One exception is the ROS timer since it does not have a corresponding behaviour (it does not interact with the external environment), but it can be used to describe internal functionalities of the node or to give flexibility to the designer, it inherits directly from \textit{component\_behaviour}.

This creates the equivalent of a ``ROS node behaviour library''. One element that is necessary to enforce in ROS is the data type associated with a specific topic, in contrast with AADL, where the data type of a port is not a mandatory property. Our solution is to use AADL prototypes; they can be used to create a placeholder for any component or subcomponent. In the thread definition for ROS behaviours, we specified data prototypes associated with the input or output ports, and the designer is forced to specialise them before instantiating the model.

Listing~\ref{lst:callback-proto} shows how prototypes are defined for the \textit{callback} thread, a similar approach is used for all the other pre-defined threads. Listing~\ref{lst:impl-proto} shows how they can be used to define the implementation of the node shown in Figure~\ref{fig:sample-node} and Listings~\ref{lst:message-example}.

At the lower level of the inheritance, there is a specific package to be designed. Other than including the ROS AADL package, it includes all the packages associated with existing ROS nodes and messages. When creating a new node, the designer can extend the existing base node provided by the ROS packages, and then add all the necessary functionalities directly from the ROS node behaviour library. This makes the process of modelling a node follow the defined structure, while at the same time, it creates a more compact and easier to design model. 

\begin{lstlisting}[language=AADL,caption={Callback template definition using prototypes.},label=lst:callback-proto]
thread callback extends cnc::message_sink
	prototypes
		message: data;
	features
		msg: refined to in event data port message;
		tf: requires data access tf;
end callback;
\end{lstlisting}

\begin{lstlisting}[language=AADL,caption={Implementation of a node where prototypes are refined to they final data type.},label=lst:impl-proto]
process implementation complex_node.impl extends ros::node.impl
subcomponents
	callback: thread ros::callback.impl (message => data std_msgs::String);
	publisher: thread ros::publisher.impl (message => data std_msgs::String);
	callback_pub: thread ros::call_pub.impl
		(message_in => data geometry_msgs::Pose,
		message_out => data geometry_msgs::Pose);
connections
	pub_out: port publisher.msg -> publisher_out;
	cb_in: port callback_in -> callback.msg;
	cb_pub_out: port callback_pub.msg_out -> callback_pub_out;
	cb_pub_in: port callback_pub_in -> callback_pub.msg_in;
end listener.impl;
\end{lstlisting}

\section{Data Modelling}
\label{sec:data}
So far, in this chapter, we described in details how it is possible to model component-based architectures together with their interactions, and how to transition from them to fully modelled ROS architectures. However, we only mentioned a crucial part of the description: data. This initial lack of details is because while AADL provides some tools for data modelling (\eg, data components), it is not a fully-fledged data description language. In a robotic system, since they are based on a  \textit{component-connector} paradigm, data play a key role to support the communication between components that happens, most of the time, through the exchange of messages or parametrised function calls. This role is so important that most of the robotic frameworks and middleware develop their language to describe data supporting communications. For example, ROS uses a simple message definition language to put the focus on the creation of custom messages when needed, and the same happens for SmartSoft where the communication objects are defined using an Xtext-based DSL. These approaches exist so the designer of the middleware or framework can have full control on the shape and style of the message definition to correctly implement the low-level communication between components; however, this fragmentation makes the definition of a general-purpose data modelling language quite challenging. Since AADL supports data components, but it lacks tools for data description, the simplest solution would be to use data component as type identifier and adopt the target message description language as type descriptor. Considering that data components are already software specific, this solution could work for everything related to communication, but it has two important limitations. First, while it works well for already existing messages that can be simply imported in the model, it removes any possibility of generality in the newly defined messages; an ideal solution would use a general description for custom messages that can be associated with different data type depending on the target platform. Second, communication-related data types are not the only type of data present in a system: a comprehensive data definition language could be used to model all data in the architectures.

Beside of communications, there is another situation where data definitions play a crucial role: parametrisation of the component. When implementing a component, there is a series of values that are calibrated for a specific configuration of the robot (\eg, maximum acceleration, camera resolution, wheel diameter, \etc). Additionally, some of these parameters may need to change at runtime, both for online calibration (\eg, measurement weight during sensor fusion, obstacle avoidance threshold, \etc) and for dynamic functionality change (\eg, indoor vs outdoor operation, high vs low performance, \etc). 

In practice, different technological solutions are used to implement parametrisation. ROS relies on a centralised component where all node parameters are stored and categorised using node-specific namespaces, at any time during execution a node can query the parameter server and retrieve a copy of the value. There is no strict differentiation between initialisation and runtime parameters, although ROS provides a separate system\footnote{http://wiki.ros.org/dynamic\_reconfigure} to perform dynamic reconfiguration. Values in the parameters server are set or via command line before running the node or by loading a YAML file. SmartSoft uses a more complex structure for parameters, there are configuration parameters that are set at deployment time and cannot be changed after the component initialisation, and there are runtime parameters that can be used to configure the component at runtime. Definition of parameters is divided into two categories, they can be internal, therefore defined together with and specifically for the component, and external, thus defined as separate parameter sets that can be reused in multiple components. The description itself of the structure of the data is done using a DLS similar to the message definition DLS. In this case, no cohesive and straightforward approach can be used to easily import the existing definitions, because parameters, as a concept, are less standardised than communication protocols.

There is one last use of data in a component that is interesting to analyse under the lens of a data modelling approach: internal variables. Components are, in the end, computer programs; thus, they may have tens of variables storing any type of value necessary for successful execution. Of course, it is pointless to try to model beforehand all the variables involved in the execution of a component, however, as we described in Section~\ref{sec:cnc}, there is a specific component behaviour, the \textit{filter} with memory, where the type of information stored in the shared memory is defined at design time because it is part of the description of the functionalities of the component. For example, let us take a component in charge of obstacle avoidance, the designer knows in advance that the component will store the map of the environment, or a multiplexer component needs to store the inputs locally before relaying them. This design approach is similar to the object-oriented programming paradigm where, before implementation, the developer designs the class with all the necessary attributes and methods. 

By describing ports and components behaviours, we already defined the component-equivalent of methods; thus, it is but a short step to fully embrace this consolidated design approach by defining the component-equivalent of attributes, too. Currently, no middleware or framework, not even those leaning more towards a model-driven development approach (\ie, SmartSoft and OROCOS/RoCK) support the definition, at design time, of internal variables of the component. This lack of support of variables with respect to parameters lies in the difference of complexity between the two. Usually, parameters are basic types (\eg, string, integer, boolean, \etc) or basic data structures (\eg, record, array, list, \etc), while internal variables can be any kind of object or data structure coming from internal or external libraries, moreover, often they require special initialisations. Unfortunately, given this complexity, we found no reasonable way to preserve the semantic of the internal variables in the same way as we could do for parameters. Nevertheless, we designed a compromise that maintains the semantic for simpler variables (\ie, basic types), but, at the same time, it allows for more complex types to be defined.

These are all the situations in which data modelling is an integral part of the design of a robotic application: communication objects, parameters, and internal variables. In the remainder of this section, we will cover the two options we explored to be able to model all these features, their specific advantages and their limitations.

\subsection{Option 1: ASN.1}
Abstract Syntax Notation One (ASN.1)~\cite{dubuisson2000asn} is an interface description language, and it is a broadly used standard in telecommunication and computer networking. The language put much focus on encoding and decoding, and it is designed to be completely independent of any computer or programming language. For these reasons, we considered it as our first option when trying to model the data exchanged in a robotic architecture.

In ASN.1, a communication protocol is defined in a module, inside, each element of the protocol (\eg, requests, responses, errors, \etc) is defined using a type. Usually, types are instantiated by a protocol data unit (PDU), however, when describing communication patterns, we only define modules (\ie, protocol descriptions) since the low-level communication is then left to the actual communication layer. Nevertheless, this general description, based on ASN.1, could be used to create a corresponding PDU and, eventually, an inter-protocol communication between different platforms. Listing~\ref{lst:asn1-ros} shows an example of how to model a ROS package containing all the possible user-defined communication objects, in particular, a message, a service and an action. In this description, an ASN.1 module corresponds to a ROS package. This binding exists for multiple reasons: first, when importing an existing definition (Pose in Listing~\ref{lst:asn1-ros}), the finest granularity available is the type defined in a specific module, this mirror the behaviour of messages defined in packages, second, modules are the only aggregator of ASN.1; therefore, they have the same conceptual functionality of packages. Lastly, types are the definition referenced by PDU, in the same way as message instances reference to a message definition in a package.

Messages are the most straightforward to define since they do not have any internal structure other than the message itself. They are defined directly using a ANS.1 type and the fields uses the same basic types expected in a normal ROS messages, value ranges (\eg, \texttt{INTEGER(1 .. 10)} and \texttt{INTEGER(-10 .. 200)}) can be used to automatically identify the correct size of the target type (\eg, \texttt{uint8} and \texttt{int16}). Arrays can be defined using the keyword \texttt{SEQUENCE OF}, eventually specifying a minimum and maximum size. One of the characteristics of ROS messages is their hierarchical definition, and they can always include other messages defined in the workspace, one typical example is the header used to timestamp messages. This is possible in ANS.1 using the \texttt{IMPORTS} keyword at the beginning of the module definition and then declare a field of a type to be of the imported definition. Of course, this raises the problem of creating all the ANS.1 definitions for ROS messages, however, given the simplicity of the message definition language used in ROS, it is a task that can be easily automated to generate all the necessary files for the entire workspace.

Internally, service definition is identical to message definition, and the same rules are used to define basic types, arrays and to include existing types. The difference is in the structure of the ANS.1 type, for service, it is necessary to differentiate between \textit{request} and \textit{response}, in the former, the developer describes the content of the request message sent by the client to the server, the latter contains the expected answer. The description of actions is similar, in this case the type is divided in three subsections: \textit{goal}, \textit{result}, and \textit{feedback}. Each subsection can have an arbitrary number of fields defined as basic types or existing types from other packages. For both services and actions, it is possible, in ROS, to send empty messages, for example, a service used to trigger a functionality has an empty request, but the result of the functionality as a response. ASN.1 supports empty sequences; therefore, the correct way to model a service or an action with empty interactions is to define the subsection but leave it empty, as seen in Listing~\ref{lst:asn1-ros} for the result of the action.

\begin{lstlisting}[language=ASN1,caption={ROS message, service and action definition using ASN.1.},label=lst:asn1-ros]
CustomPackage DEFINITIONS AUTOMATIC TAGS ::= BEGIN
	IMPORTS Pose FROM Geometry_msgs;
	CustomMessage ::= SEQUENCE {
		x INTEGER(1 .. 10),
		y REAL,
		pose Pose
	}
	CustomService ::= SEQUENCE {
		request SEQUENCE {
			a INTEGER(-10 .. 200),
			b SEQUENCE (SIZE (1..10)) OF INTEGER
		},
		response SEQUENCE { sum INTEGER }
	}
	CustomAction ::= SEQUENCE {
		goal SEQUENCE { pose Pose },
		result SEQUENCE {},
		feedback SEQUENCE { pose Pose }
	}
END
\end{lstlisting}

We have to follow a different approach to model the internal state of the node. In this case, it is necessary to define both the module (\ie, the structure of the internal state) and the PDU (\ie, the specific configuration of the internal state); however, these two specifications will be used at different times in the design, development and deployment cycle of the architecture. As for the communication objects, everything resides in the same ASN.1 module, but in this case, each module represents a specific node. However, if two nodes share the same parameters and variables configuration, they can share the same module (\eg, different implementation of the same functionality). Listing~\ref{lst:asn1-ros-is} shows how an hypothetical internal state of a node could be modelled using ASN.1, while Listing~\ref{lst:asn1-ros-is1} represent a possible instance. The list of parameters and variables are defined each in their own type.

For parameters, the description is quite simple, since they only use basic types and, potentially, nested records. Basic types are matched directly with their ASN.1 counterparts, and again the range can be used to specialise type during implementation automatically or to define boundaries for the parameters. Often, parameters related to the same functionality (\eg, configuration values of a planner) are grouped together in a record data structure (\eg, C struct), to achieve the same result it is possible to declare the parameters as nested \texttt{SEQUENCE}. 

For most of variables definitions, the process is the same as parameters, it is possible to use basic types and nested data structure to define and organise basic variables. The difference between the two lays in what we call ``complex'' variables, here the developer is not forced to use only basic types but can use data structure of unpredictable complexity (\eg, ROS messages for storage, maps, point clouds, behavioural trees, \etc). It is unreasonable to try to capture this complexity in a high-level design specification; therefore, we defined a new ASN.1 type called \texttt{Complex}. This type has two fields: \texttt{type}, the actual type of the variable in the target programming language (\eg, \texttt{costmap\_2d::Costmap2D} for a ROS costmap in C++), and \texttt{include}, the resource to be included to use the specific data type (\eg, \texttt{costmap\_2d.h}). The example and the structure presented here is specifically targeted for a C++ implementation of a ROS node, but the concept of the complex variable can be easily translated to different programming languages. From a design point of view, the variable act as a conceptual placeholder for a more complex implementation, while during code generation the complex description can be used to create the internal state of the component automatically. 

For the description of the internal state, we can combine the module with the PDU to create a complete definition of the node. While in the module we can define default values for both parameters and variables, their actual values are going to change significantly depending on the particular deployment. To capture this, we can use the PDU to specify the current instance of the internal state, and automatically generate a specific initialisation for parameters and variables; complex variables, of course, are the exception, since the information contained in the PDU are used to define them during code generation.

\begin{lstlisting}[language=ASN1,caption={Internal state of a node modelled using ASN.1},label=lst:asn1-ros-is]
InternalState DEFINITIONS AUTOMATIC TAGS ::= BEGIN
	Complex ::= SEQUENCE {
		type UTF8String,
		include UTF8String
	}
	Parameters ::= SEQUENCE {
		size INTEGER DEFAULT 1,
		dimensions SEQUENCE {
			height	REAL DEFAULT 1.0,
			width	REAL DEFAULT 2.0
		}
	}
	Variables ::= SEQUENCE {
		counter INTEGER,
		map Complex
	}
END
\end{lstlisting}

\begin{lstlisting}[language=ASN1,caption={Internal state instance defined in ASN.1},label=lst:asn1-ros-is1]
params Parameters ::= {
	size 2, 
	dimensions { height 2.0, width 3.0 }
}

value Variables ::= { 
	counter 0,
	map {type "costmap_2d::Costmap2D", include "costmap_2d.h"}
}
\end{lstlisting}
 
\subsection{Option 2: JSON with schema}
 JavaScript Object Notation (JSON)~\cite{crockford2006application} is an open-standard file format, and it is a human-readable text where objects are codified in attribute-value pairs and array data types. While it was originally derived for JavaScript, hence the name, it is a language-independent data format, it is very common and massively used for asynchronous browser-server communication. While JSON is excellent to describe object instances (\ie, the actual data content), it is normally used with the assumption that the data structure is codified somewhere else (\eg, in the source code defining the object). However, there are various initiatives to define the structure, and the content of the data using JSON, the one we are using in our approach is called JSON Schema~\cite{pezoa2016foundations}; it is a vocabulary to annotate and validate JSON documents. The capability offered by the schema definition, combined with the extreme popularity of JSON made it our second option for data modelling.
 
A complete description based on JSON schema is composed by the schema and an instance of the data. Following a similar approach to ASN.1, for the description of messages, services and actions, we are going to define only the schema, and leave the instance to the underlying communication protocol. As before, the general description defined using JSON schema can be used to create JSON documents with the same meaning of the messages exchanged by the underlying middleware or framework. This is extremely useful since JSON is one of the most common standards for the web; therefore, through this description, it is possible to create a web-compatible interface for the robot. 

Differently from ASN.1, each schema is not a complete package, but a single message, service or action definition, the same as it happens in ROS. To model the concept of packages it is possible to follow various routes, for example, locate the schema in the same folder, in the same way as ROS does, or exploit the unique id (\texttt{\$id}) to categorise the schema, in our approach we use both. Listing~\ref{lst:json-ros-msg}, \ref{lst:json-ros-srv} and \ref{lst:json-ros-act} show three different schemas representing a message, a service and an action, all of them defined in the same ROS package. Physically, these three descriptions are defined in three separate files and are stored in the same folder, exactly as it would happen for ROS definitions in the same package. Moreover, the \texttt{\$id} is structured to specify both package and defition name.

As before, messages are the simplest to model, since they do not a nested structure. With JSON schema, it is possible to directly define the list of field of the message and specify their type. The available basic types are \texttt{string}, eventually matching a pattern, \texttt{number}, real numbers where it is possible to specify the boundaries, \texttt{integer}, a subset of integer numbers, \texttt{boolean}, for a true/false field, and \texttt{null}, for empty fields. Additionally, a field can be of type \texttt{array} when it represents an array, in JSON there is no restriction on the type of the elements of an array; therefore, JSON schema supports multiple options ranging from all the elements having the same type to each element has a different type. In ROS, only same-type array are admitted, in Listing~\ref{lst:json-ros-srv} we modelled an example of a 10-elements integer array. JSON schema supports referencing external schemas, and this can be used to model how in ROS, a message field type can be a previously defined message.

Additionally, most JSON schema validators support the use of URL as \texttt{\$id} and \texttt{\$ref}, this means it is possible to use the online location of a schema definition as the id and then use the same location during validation. In summary, only the custom message schema has to be parsed directly, and everything else can be remotely checked only when necessary. As always, this raises the problem of generating the schema of all the existing messages, but not only this can be done automatically, they can be collected in a single online library (\eg, ROSWiki) or hosted in the same repository together with the ROS source code. 

Regarding the description of types, services are defined in the same way as messages. They can use basic types, arrays or reference existing messages. However, their schema is divided in two section defined as two different objects: \textit{request} and \textit{response}. As before, the former describes the message sent to the server and the latter models the answer received. The same structure based on sub-objects is followed by the action description, this time divided in three different parts: \textit{goal}, \textit{result} and \textit{feedback}. Each subsection follows the same rules of the message, can have multiple fields as basic types, arrays or reference existing definitions. One significant difference between JSON schema and ASN.1 is how they describe empty messages. In JSON schema empty brackets (\ie, \textit{\{ \}}) represent the wildcard (\ie, it matches every sequence), the correct way to specify an existing, yet empty, field is to declare it as type \texttt{null}, as seen in Listing~\ref{lst:json-ros-act} for the result of the action.

\begin{lstlisting}[language=JSON, caption={ROS message definition using JSON schema},label=lst:json-ros-msg]
{
	"$id": "custom_package/CustomMessage.schema.json",
	"type": "object",
	"properties": {
		"x": { "type": "integer", "minimum": 1, "maximum": 10 },
		"y": { "type": "number" },
		"pose": { "$ref": "geometry_msgs/Pose.schema.json" }
	}
}
\end{lstlisting}

\begin{lstlisting}[language=JSON, caption={ROS service definition using JSON schema},label=lst:json-ros-srv]
{
	"$id": "custom_package/CustomService.schema.json",
	"type": "object",
	"properties": {
	"request": { "type": "object",
		"properties": {
			"a": { "type": "integer", "minimum": 1, "maximum": 10 },
			"b": { "type": "array", "minItems": 1, "maxItems": 10,
						"items": { "type": "number" } }
		}
	},
	"response": { "type": "object",
		"properties": { "sum": { "type": "integer" } }
	}
	}
}
\end{lstlisting}

\begin{lstlisting}[language=JSON, caption={ROS action definition using JSON schema},label=lst:json-ros-act]
{
	"$id": "custom_package/CustomAction.schema.json",
	"type": "object",
	"properties": {
		"goal": { "type": "object", 
			"properties": { "pose": {"$ref": "geometry_msgs/Pose.schema.json"} }
		},
		"result": { "type": "null" },
		"feedback": { "type": "object",
			"properties": { "pose": {"$ref": "geometry_msgs/Pose.schema.json"} }
		}
	}
}
\end{lstlisting}

As mentioned before, when describing the internal state, we have to use both the instance and the schema. The former represents the actual values of the parameters and variables, and the latter contains the model that validates the structure of the instance. When using JSON schema, we opted for a hierarchical approach based on a double validation. First, we validate the instance to verify the general structure, and then we use the component-specific schema to validate the content. Listing~\ref{lst:json-is-base} shows the schema used for the first step of the validation. The designer has to follow this model, but he does not have to implement or provide it since it is embedded in the validation and code generation process. The base schema verifies that the instance is divided in two, and no more (see \texttt{additionalProperties} set to false), subsections: parameters, values that are initialised at the beginning of the life cycle of the node and are not subject to changes, and variables, values used to capture the evolution of the internal state of the component.

\begin{lstlisting}[language=JSON, caption={Base schema of the internal state defined using JSON schema},label=lst:json-is-base]
{
	"$ref": "#/InternalStateBase",
	"InternalState": { "type": "object", "additionalProperties": false,
		"properties": {
			"Parameters": { "type": "object", "additionalProperties": true },
			"Variables": { "type": "object", "additionalProperties": true }
		}
	}
}
\end{lstlisting}

Listing~\ref{lst:json-is} represent the schema of a hypothetical internal state of a component, and it is the definition used in the second step of the validation process. Following the structure enforced by the base schema, parameters and variables are defined each in their own object. Since parameters are defined using basic types and nested records, their description is quite straightforward. JSON schema types are used to define their implementation-specific counterparts, while the \texttt{object} type can be used to define nested records. For variables definition, the process is similar, basic types variables are defined using JSON schema types, and it is possible to create nested structures to organise them.

Similarly to ASN.1, we defined a new object to capture ``complex'' variables. This object has exactly (enforced by setting \texttt{ad\-di\-tion\-al\-Prop\-er\-ties} to false) two values: type, defines the actual complex type of the variable, and include, in a C/C++ specific implementation it provides the resource to be included to use the complex type correctly. The \textit{complex} object can be redefined to match the requirements of different programming languages; for example, Python does not require a type but may need to specify which resource to import. The schema presented in Listing~\ref{lst:json-is} represents only half of the necessary description to model the internal state of a node completely. It is the static design, and the JSON instance completes it. An example of an instance compatible with the two schemas presented is in Listing~\ref{lst:json-inst}.

\begin{lstlisting}[language=JSON, caption={Internal state defined using JSON schema},label=lst:json-is]
{
"$ref": "#/CustomInternalState",
	"InternalState": { "type": "object",
	"properties": {
		"Parameters": { "type": "object",
		"properties": {
			"dimensions": { "type": "object",
			"properties": {
				"height": { "type": "number", "default": 1.0 },
				"width": { "type": "number", "default": 2.0 }
			} },
			"size": { "type": "integer", "default": 1 }
		} },
		"Variables": { "type": "object",
		"properties": {
			"counter": { "type": "integer" },
			"map": { "$ref": "#/complex" }
		} }
	} },
	"complex": { "type": "object", "additionalProperties": false,
	"properties": {
		"type": { "type": "string" },
		"include": { "type": "string" }
	} }
}
\end{lstlisting}

\begin{lstlisting}[language=JSON, caption={Internal state instance defined in JSON},label=lst:json-inst]
{
	"Parameters": {
		"dimensions": { "height": 2.0, "width": 3.0 },
		"size": 2
	},
	"Variables": {
		"counter": 0,
		"map": { type "costmap_2d::Costmap2D", include "costmap_2d.h" }
	}
}
\end{lstlisting}

\subsection{Comparison}
Both ASN.1 and JSON schema are powerful enough to completely capture the description of communication objects and the internal state of the components; therefore, they are almost interchangeable as data description languages. Additionally, ASN.1 supports JSON encoding rules (JER), so, in theory, it would be possible to create a direct conversion between the two different representations. All considered, it may not be necessary to pick a specific option to model the data in the architecture; however, there are some reasons one approach may be more suitable than the other. ASN.1 is a widely used protocol description language that supports multiple encodings and can deal automatically with various low-level communication issues (\eg, endianness, payload size, \etc), this is extremely useful when modelling communication with physical devices, therefore it can be used when dealing with sensors and actuators. However, ANS.1 can be too low-level for most applications, and while widely used, it is not a widely known language. JSON, on the contrary, was created to encode JavaScript objects; thus, it does not capture low-level details, but it is a de facto standard for web communications and NoSQL databases. This means it can be used to create communication bridges between different technologies (\eg, ROS and SmartSoft), web APIs for robots or advanced logging systems.

In summary, both approaches are suitable for modelling all the data exchanged in robotic systems, but the specific characteristics of the languages make them more or less useful when facing specific problems. 
%*****************************************
