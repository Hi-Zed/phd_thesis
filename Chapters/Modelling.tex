%************************************************
\chapter[Modelling]{Modelling}\label{ch:Modelling}
%************************************************

\begin{flushright}{\slshape the sciences do not try to explain, they hardly even try to interpret, they mainly make models. By a model is meant a mathematical construct which, with the addition of certain verbal interpretations, describes observed phenomena.} \\ \medskip
    --- John  von Neumann
\end{flushright}

As said by von Neumann, science is about making models. They can be used to simplify a phenomena and make it easier to understand and define, moreover, a model can be used to quantify or visualise reality. Knowledge extracted by the process of modelling can be reused to create a simulation (\ie, another form of modelling) of the system under analysis. For all these reasons, and because is one of the most innate ability of humans, modelling has always been the cornerstone of science, engineering and arts.

Modelling in engineering is an essential tool for design, analysis and simulation, models have different characteristics and take various shapes. A collection of mathematical formulas can be used to describe a physical phenomena (\eg, friction between the ground and the wheels), or the behaviour of a system (\eg, a control system). Differently, a flow chart is a graphical model of an execution process, while pseudo-code is a textual one. A 3D model capture the physical shape of an object and can be used to study the design or the space occupancy.

This chapter presents various modelling techniques that we used to describe multiple aspect of the architecture of a robot. First, an introduction to the  Architecture Analysis \& Design Language (AADL), a description of the concepts behind the language and how it can be used to model complex system. Then, how the language is exploited to model robotic system and more in particular ROS-based architectures.  Lastly, since AADL is not a data modelling language, we present two approaches based on Abstract Syntax Notation One (ASN.1) and JavaScript Object Notation (JSON) to model the data exchanged in the system (\ie, ROS messages) and the internal state of each component.

\minitoc
\newpage

\section[The component and connector paradigm]{The component and connector \\paradigm}
\label{sec:cnc}
In robotics, the most popular middlewares and frameworks are based on a \textit{component-and-connector} paradigm, while different approaches implement it in different ways, the underlying conceptual structure is the same. In ROS, it is represented by the computation graph, a peer-to-peer network of processes that are processing data together. Here, following the usual terminology of graphs, the components are called nodes, while the connections are represented by asynchronous topics or synchronous services; in both cases the communication happens by exchanging messages. In SmartSoft, the underlying technological approach of the SmartMDSD toolchain, the structure is based on components, communication patterns and communication objects. Components are interconnected to each other by using one of the four possible communication patterns: two synchronous based on a client/server paradigm (\ie, send and query) and two asynchronous based on a publisher/subscriber paradigm (\ie, push and event). All the patterns communicate by exchanging communication objects. Another example is the Robot Construction Kit (RoCK), which is based on the component model of the Orocos Real Time Toolkit (RTT). In RoCK, and consequentially in Orocos, the architecture is, again, based on components connected to each other through ports. One last example is the OpenRTM-aist middleware developed by the Japanese National Institute of Advanced Industrial Science and Technology. They fully embraced the component based approach, where a robot is made by multiple subsystem, and each of them is a collection of components. Components communicate to each other using connections established between predefined ports. The popularity of the \textit{component-and-connector} paradigm is not coincidental. In their structure, robots are a system of systems, a hierarchical collection of components interconnected together to create a working apparatus. Physically, a robot is a collection of sensors and actuators; same goes for the behaviour, simple low-level independent functionalities are not enough to implement even the simplest robot. Given all these needs, the most natural approach is to decompose the system in different and simpler subsystems and to simplify and characterise their interactions by the use of interfaces; the result is a \textit{component-and-connector} paradigm. 

The aim of this work is to provide a general and flexible representation that can be used to model an architecture that captures the design a robot and it is compatible, at least at an higher level of specification, with multiple middlewares and frameworks. To do so, we defined some common design patterns often used when creating robotic architectures. As already mentioned, the first key design approach is the use of components and connections, but, of course, this is a very high-level description and it is only useful to define the topology of an architecture. To better define an architecture without including technological details (\ie, specify a middleware or framework), we have to define a general description for component functionalities and we have to specify the nature of each connection. By analysing the existing solutions for robotics (\ie, ROS, SmartSoft and Orocos/RoCK), we identified four possible component behaviours that can exist (and co-exist) in a component.

\paragraph{Source} A component expresses a \textit{source} behaviour when it is a generator of data or events. An example is a simple ROS node implementing a publisher, it generates messages and circulates them in the computational graph. In SmartSoft there are two communication patterns that, implemented in a component, evoke this behaviour: push, to generate message and send them to other components, and event, a data-less communication to trigger action in other components. This type of behaviour is used for device drivers, since they create and circulate a digital version of the analogue input they detect, but also it used by coordinator components, they are in charge of initiating high level functionalities by generating an event or a specific message.

\paragraph{Sink} A \textit{sink} is a component that consumes data or events. In ROS, a node is a sink when it implements a subscriber that receives, processes, and consumes messages. The counterpart in SmartSoft is, again, a component that implements the same two communication patterns (\ie, push and event), but this time it is on the receiving side of messages and events. This type of behaviour is implemented by component controlling actuators, they receive commands from other components and consume them to operate a physical device. Alternatively, it is used by storage managers or loggers, they simply collect all possible messages and store them. Lastly, any component activated by an event implements a corresponding \textit{sink} to receive and mange the trigger.

\paragraph{Filter} The most common behaviour for a component is the \textit{filter}. This type of component receives messages or events as an input and processes or relays them to the create an output. To describe more precisely the internal functioning of this behaviour, we have to distinguish two categories: without or with memory. 

In the former, the component does not store in any way the data received, they are processed and directly re-circulated in the system. This approach is common when doing simple conversions (\eg, change the unit of measurement or the coordinate system) or when it is necessary to resample the data (\eg, change the frequency or zero-pad the messages). In ROS, it is implemented by processing the received message directly in the subscriber callback and publish it before the leaving the callback environment. The latter behaves similarly to a combination of a \textit{sink} and a \textit{source}; messages or events are received by the component and stored locally, then, at a later time, recalled from memory, processed and relayed in the system. This approach is used when doing more complex processing, for example when multiple messages need to be processed at the same time (\eg, smoothing a velocity set-point), or when multiple inputs need to converge in a single output (\eg, combining multiple laser rangefinder measurements in a single one). In ROS, this happens when messages are processed in a callback but not completely discarded at the end, and later, in the main loop or in a different callback, they are processed and circulated back in the computational graph.

\paragraph{Reactive} A component has a \textit{reactive} behaviour when its functionalities are synchronously triggered by a message or an event, it is usually implemented by using a remote function call. In ROS this kind of behaviour is exemplified by services; they offer a public interface that can be called by external components and react with a synchronous execution of a function that may return a value.  SmartSoft implements a similar synchronous system, but differentiate between a one way communication with no answer (\ie, send and forget) and a two way communication with a specific response. This behaviour is used to delegate to a central component a specific functionality (\eg, centralised conversion system), to activate a remote functionality (\eg, component \mbox{re-initialization}), or to guarantee a timely answer to a request (\eg, soft real time functionalities).

Implicitly, by describing the possible behaviours of a component, we already outlined the nature of the messages exchanged: a connection can be data-based or event-based. In a data-based connection, messages with a specific content are exchanged between components. Usually, a specific communication channel only support a pre-defined data format, but, in theory, it is possible for a data-based connection to not specify the nature of the message exchanged. Each middleware or framework uses a different language to describe data format, for example both ROS  and SmartSoft use their own domain specific language to define communication objects. This is source of a strong and unnecessary fragmentation, because in the end all middlewares and frameworks rely on basic data types and data structures, that are already covered by numerous standard data description languages. Event-based connections fall on the opposite side of the spectrum, because the content of the communication is irrelevant, the key element is the communication itself. The receiver only needs to detect an active communication to collect the event generated by the sender. In practices, it is common to implement event-based communications as data-based communication carrying an empty message, this approach is exactly what ROS does, since it doesn't support any pure event-only communication, but any communication channel (\ie, topics and services) supports standard empty messages. In SmartSoft, event-based communication is supported only paired with a publish/subscribe paradigm, since the \textit{Event} communication pattern exists only for asynchronous communications.

The complete the description of an architecture based on the \textit{component-and-connector} paradigm, we need to analyse the cardinality of the connections. Potentially, there are four different cardinality:
\begin{itemize}
\item \textit{1-1}, this is an exclusive connection where the a source is directly connected to exactly one destination.
\item \textit{1-n}, in this type of connection the stream of messages or events generated by a single source can be connected to one or multiple destinations.
\item \textit{n-1}, to achieve this configuration multiple sources need to converge in a single destination.
\item \textit{n-n}, this is the most permissive of all cardinalities. In this configuration there is no limit in the number of sources and destinations for a single communication channel. By using a local policy to this type of communication it is possible to implement all the previous ones, however when a communication is \textit{n-n} by design it is impossible to guarantee other cardinalities. The result is a very flexible, yet unpredictable connection.
\end{itemize}
In practice, robotic middlewares and frameworks, rarely implement all four options. In ROS, topics are implemented as pure \textit{n-n} communication channels, since they follow a \textit{publish-and-forget} paradigm. Any number of publisher can publish messages on a topic and each subscriber receive a copy of the message. There is no ownership of a messages after it is published on a topic. While the communication supports a full \textit{n-n} cardinality, in practice, it is never used as such, but always as multiple publisher and a single subscriber (\ie, \textit{n-1}) or a single publisher and multiple subscribers (\ie, \textit{1-n}). ROS services are inherently \textit{n-1}, since only a single server can provide a specific service, while multiple clients can request it. SmartSoft is more strict in the definition of the cardinality of its communication patterns: all the patterns with a publish/subscribe structure (\ie, push and event) have a \textit{1-n} cardinality, all the patterns following a client/server approach (\ie, query and send) support only a \textit{n-1} cardinality.

\section{Architecture Analysis \& Design Language}
\label{sec:aadl}
The Architecture Analysis \& Design Language is a very powerful modelling language designed to capture the architecture of embedded systems by using architectural models that provide a well-defined and semantically rich description of the runtime architecture. This description encompasses multiple aspects of the system: hardware components, to encode the underlying physical layer of the system, software components, to define the runtime behaviour of the architecture, the interaction between them, for example deployment of software on specific hardware and communication between different execution units, and the defining properties of each modelled element, to better characterise any particular system.

In AADL, components are defined using a dichotomy between specification and implementation. The component type declaration is used to define the category (see Table~\ref{tab:categories}) and the interfaces (\ie, features) of the component; this correspond to a specification sheet that provides a description of the component as a black box. For a specific type it is possible to define multiple component implementation declarations, each of them defines internal structure of the component (\ie, subcomponents and their interactions). This is equivalent as defining multiple blueprints for building a component from its parts, each of them a possible implementation of an already defined specification. To specify even more the characteristics of a component, especially its runtime behaviour, it is possible to use properties. AADL already provides a collection of predefined properties, and more are available by including standard annexes for specific analyses, moreover, an user can defined his own properties by defining additional properties sets. Together, all these declarations (\ie, type with implementation with a set of properties) define a pattern for a component, which are referred as component classifiers.
 
\begin{table}
    \myfloatalign
    \begin{tabularx}{\textwidth}{ l X} \toprule
        \tableheadline{Category} & \tableheadline{description} \\ \midrule
        \multicolumn{2}{c}{Application software} \\ \midrule
        process & Execution unit with a protected address space.  \\
        thread & A schedulable execution path. \\
        thread group & An abstraction to logically organise threads. \\
        data & Abstraction for data units.  \\
        subprogram & Callable sequentially executable code. It represents call-return functions.  \\
        subprogram group & An abstraction to logically organise subprograms. \\ \midrule
        \multicolumn{2}{c}{Execution platform} \\ \midrule
        processor & Schedule and executes threads and virtual processors. \\
        virtual processor & Logical resource that can schedule and executes threads. It must be bound to one or more physical processor. \\
        memory & Stores code and data. \\
        bus & Interconnects processors, memory and devices. \\ \midrule
        \multicolumn{2}{c}{Composite} \\ \midrule
        system & Integrates software, hardware and other system components. \\ \midrule
        \multicolumn{2}{c}{Generic} \\ \midrule
        abstract & Define a runtime neutral component that can be refined into another component category. \\
        \bottomrule
    \end{tabularx}
    \caption[Component categories]{Component categories.}  \label{tab:categories}
\end{table}
 
Component types and implementations are defined and organised using packages; they are, essentially, libraries of component specifications that can be used in multiple architecture definitions. Packages have public and private sections to support information hiding. The public section of a package contains all the specification that will be available to other packages, while the private section can be used to hide the specific component implementation. In AADL, everything is organised in packages, an exception are property sets. They are special container for user-defined properties, they act like packages and can be imported in other definition, but only properties can be defined in properties set.

To model a full architecture it is necessary to first define all the necessary component classifiers, or import the existing ones in previously defined packages. In the case of a robot, for example, it is necessary to define the physical sensors as devices and the execution platform as a combination of processors, buses and memories. On the software side, the designer could import previously defined software component as processes or define more in new packages and then import them. After this initial definition, a complete architectural description is created by integrating in a fully specified system implementation instances of the previously defined component classifiers. This hierarchy represents all the interactions between components and the architectural structure of the modelled system. These interactions cover multiple aspect of the system, they encode the communication between components through data and events, and the physical connections between them. They also capture the assignment of software to hardware (\eg, on which physical processor or processing unit a specific process will be executed). The full model of the system under analysis is obtained by instantiating this top level system implementation. This instance model can then be used to analyse operational properties of the system, ranging from syntactic compliance and basic interface data consistency to assessment of quality attributes and behaviours.

The key characteristics that make AADL suitable for our approach are the inheritance between components and the possibility to use partially defined components and interfaces that can be refined later in the design process. In practice, inheritance exists as a form of extension of existing components. A new classifier (\ie, component type and implementations) can be defined by extending an existing one; the extended classifier inherits all the characteristics of the base one: interfaces, subcomponents, properties, internal connections and modes. The extension declaration can be used to refine the new classifier by adding new elements, specifying existing elements inherited from the base classifier, restricting subcomponents to a specific mode, completing the definition of partially defined sections. 

Partial definition is achieved in two ways: by using abstract components or by exploiting prototypes. The \textit{abstract component} is a generic category that can be used in place of any other component type or implementation without having to specify a runtime category. A model with an abstract component cannot be instantiated, however they are extremely useful to define the initial conceptual description of the system during an iterating design process, or architecture templates and patters that can be used as reference libraries by designers. The \textit{prototypes} act as placeholders for classifiers and they can be referenced anywhere a classifier would normally be referenced. The actual classifier can be specified later when referencing the parametrised component, \eg, when extending the classifier or when declaring a subcomponent. Prototypes are useful to create reference architectures or configurable product line families by providing, essentially, a parametrised classifier template that a designer can easily specify while following the structure already provided. An example is the data type exchanged between two components; the template of the component define the existence of the communication channel, but it uses a prototype for the actual type of the data. Because of the prototype, the designer needs to define a data type in order to be able to instantiate the model, but there is no restriction of the original definition of the template.

AADL is a formal declarative language described by a context-free syntax. This well-defined semantics is a key aspect of the language and a strong advantage, especially for quantitative system architectural analysis. Textual AADL is the main, more straightforward and detailed way to interact with the language, however, there are standard graphical representation that correspond to the textual definition. During the design of an AADL model, either of both representation can be used, a good strategy is to first define the skeleton of the model graphically, and then finalise the description using textual AADL. This process is supported by the Open Source AADL Tool Environment (OSATE), in this development environment a designer can easily switch between one representation of the language and the other, and any modification is propagated in all representations.

In the reminder of this section, we present more in details the component categories of AADL relevant to our work. We provide a description of the logical meaning of each category and their interactions, to better justify how used them to model a robotic architecture.

\subsection{Software components}
These categories are used to model the executable architecture of the system, they encompass functional units as processes, execution path as thread or thread groups and executable code such as functions, procedures and libraries as subprograms and subprograms groups. Moreover, the data category can be used to represent the application software artefacts, some examples are data types, configuration files, internal data structures and communication messages. In addition to the semantic provided by the category itself, additional information associated to runtime (\eg, dispatch protocol and frequency of a thread) and non-runtime (\eg, source code associated to a specific subprogram) can be specified using properties.

\paragraph{Process} It represents an encapsulated execution unit; the address space, the persistent state and all internal resources are all protected and they are not accessible by external elements directly. The internal functions of the process are exposed using different kind of ports and interfaces (\ie, features): event ports can be used to trigger a behaviour or data ports for communication. Syntactically, a designer could provide access to the internal persistent state of the process, but, logically, processes usually represent protected address spaces. The process category is, basically, just a container that defines an executable entity, therefore it doesn't include an implicit definition of a thread; this means that a complete process specification has to include at least one explicitly defined thread. The allowed subcomponent categories are: thread, thread group and data. Properties can be used to specialise the runtime behaviour of a process, for example it is possible to specify the source code associated with the process, or even the actual binary that will be executed. 

\paragraph{Thread} It represents an execution path through code, that could, potentially, be executed in parallel with other similar execution paths. The executable code modelled by a thread exists within the protected address space defined by the process container. Although the name of this category suggest a direct binding between the model of a thread and a physical thread on a system, conceptually, an AADL thread is more versatile. A thread can be implemented by a single operating system thread, or represent one of multiple logical threads mapped on a physical one. A thread may also represent an active object. Logically, an AADL thread revolves around the property of being schedulable; threads can be bound to processors or virtual processor and they have multiple properties to specify their scheduling behaviour. The possible values of the \textit{Dispatch\_Protocol} property cover the most common behaviour expected by a schedulable execution path.
\begin{itemize}
\item Periodic, a repeated fixed time interval dispatch with the assumption that the execution time is shorter than the period.
\item Aperiodic, a port-based dispatch triggered by an external source, if the thread is still executing when a new dispatch arrives a queue based system is used.
\item Sporadic, the dispatch is triggered by external events on a port, but a new dispatch cannot happen before a specific interval of time.
\item Timed, thread are dispatched after a specific amount of time if no event triggers it before. Basically, it is an aperiodic dispatch with a time-out.
\item Hybrid, this dispatch method combines a periodic and aperiodic. A thread is dispatched by an external event or after a fixed amount of time.
\item Background, a thread is dispatched once and it is executed until completion.
\end{itemize}
A thread can exist only within a process or as a direct subcomponent or as part of a thread group. The possible subcomponents of a thread are: data, to capture a persistent local state, or subprogram and subprogram group, to model a local call to a functionality. The interaction between threads can happen through ports, by accessing shared data component at process-level or by calling a subprogram serviced by another thread.

\paragraph{Thread group} It can be used to organize threads within a process in a hierarchy when they are logically related or when it is necessary to create a encapsulated space with respect to the rest of the process. The unified frontier presented by threads in the same group can be used as a common interface when a designer wants to capture, at the same time, an high level functionality and the low level constituting elements. Other than thread and other thread group, the legal subcomponents are data, subprogram and subprogram group. All these subcomponents are directly accessible by the threads in the group, but are reachable by any external element only through ports.

\paragraph{Data} It can be used to model any kind of data exchanged, saved or defined in the system. Data component instances can appear in three different forms: as data subcomponents to represent persistent data (\eg, the state of an object), included in data or event data port to specify the type of data exchanged in the specific communication, as parameters declaration of subprograms. As subcomponents, a data component can have more data components, to model a record-like structure, or subprograms, to evoke the concept of a method associated to a specific data type or class. AADL is not a data modelling language, however provides enough flexibility to be used as such. The most reasonable approach is to use the data category to map all the information relevant to the model, and then exploit properties to specify a more detailed description of the data using a more suitable language.

\paragraph{Subprogram} It represents a callable unit of sequentially executable code. The subprogram type represent the signature of function, procedure or method modelled, while the subprogram implementation represent the internal functionalities. The implementation is not required to instantiate a model, however, if necessary, data components can be used to describe local variables and nested subprograms define the execution sequence. Subprograms support data access to access a shared persistent state or outgoing ports to model exceptions and errors; moreover, data components can be used to model parameters and the return value. There are two ways to model subprogram calls: by referring to the subprogram classifier, or by using a using a subprogram access feature. The first approach is used when referring directly to the subprogram (\eg, to specify the subprogram as the executable code of a thread), while the latter is used to model indirect calls (\eg, to model remote service/procedure calls or, in combination with a data component, to model an object oriented approach). Various properties of the subprogram can be used to specify the actual executable code to be used in the implementation (\eg, \textit{Source\_Name}, \textit{Source\_Text} and \textit{Source\_Language}), others are related to the calling and execution of the subprogram itself (\eg, \textit{Allowed\_Subprogram\_Call} and \textit{Compute\_Execution\_Time}).

\paragraph{Subprogram Group} It can be used to represent a collection of callable routines. For example, a subprogram group type models the API of a software library by using a series of subprogram accesses, while different subprogram group implementations can be used to model multiple implementations of the same library (\eg, different versions or implementations in different languages). The possible subcomponent of a subprogram group are: subprogram, to define the actual content of the group, subprogram group, to create a multi-level hierarchy, and data, to define a persistent state shared by all subprograms in the group.

\subsection{Execution platform components}
These categories are used to model the resources of the computer system and the elements of the external physical environment. To model the physical resources of the system, a designer can use processor,  bus and memory categories. Each of these categories represent the concept behind these physical system and not the actual object, so a processor can be a CPU, but also a processor board including operating system functionalities. In the same way, a bus component can be used to model a physical bus on a board, or a network connection such as Ethernet or CAN bus. Both these components have their virtual counterpart: a virtual processor can represent a scheduler or a virtual execution environment, while a virtual bus can model a communication protocol or a virtual channel. Memory components represent any kind of memory present in a system, from RAM to cache as well as persistent memory such as hard drives. To model sensors, actuator or physical elements of the system it is possible to use devices.

\paragraph{Processor} The definition of processor is related to the concept of thread. A processor represents the hardware and associated software that is in charge of scheduling  and executing of threads. In practice, this category can be used to model both low-level hardware of an embedded system and the high-level platforms together with operating system services, depending on nature of the model and the system. To support this, memory and bus are possible subcomponents and they can be used to define the internal function of the execution platform. To correctly instantiate the model, a processor has to be associated with a memory, it can be internal as a subcomponent or external connected via a bus. The properties available can be used to specify the runtime characteristics of the hardware (\eg, \textit{Clock\_Period}) or the physical description of the component (\eg, \textit{Hardware\_Description\_Source\_Text}).

\paragraph{Virtual processor} It represent the logical counterpart of a processor, it is a virtual resource for scheduling and executing software. It can be used to model any kind of virtualization platform (\eg, Java VMs, Docker containers, virtual environments), partitions of physical processors or hierarchies of schedulers. To instantiate a model a virtual processor has to be associated to a physical one, or as a subcomponents or by binding. Properties specific to this category are related to the binding between virtual and real processors, the others are the same of the processor category, with the exception of those used to describe the physical hardware (\eg, hardware description and clock properties).

\paragraph{Memory}  It represents any kind of storage for data and executable code. A memory category can be used to model randomly accessible physical storage (\eg, RAM and ROM), reflective memory, or permanent storage. A memory component can be used as a subcomponent of a processor to model a complete execution platform, or can exist as independent in a system to define more complex architectures or shared memories. Typically, two types of software components are bound to memories: process and data. A process has memory requirements for code, static and dynamic data, while a data component bound to a memory represent persistent data shared between different threads. Properties can be used to define the physical characteristics of the memory, such as word and total size, base address and access protocol.

\paragraph{Bus} It represents the physical connection between hardware components and the associated communication protocols. Some examples of the type of connection modelled by the bus category are PCI, CAN, Ethernet and wireless network. Another use of this category is to represent physical resources distributed to multiple physical components such as electrical power. Bus can exists as a subcomponent to any other execution platform category (\ie, processor, memory, device), however, nested buses are not permitted; only a virtual bus is accepted as subcomponent. Properties can be used to specify details about the physical connection (\eg, \textit{Transmission\_Time} and \textit{Allowed\_Message\_Size}).

\paragraph{Virtual bus} It represents a logical abstraction of a communication channel, such as a virtual partition of a physical bus, communication protocols or hierarchies of protocols by defining dependencies between multiple virtual buses. Since this category can be used to represent protocols, it can be referred in other components properties (\eg, a processor specifying \textit{Provided\_Virtual\_Bus\_Class}) to specify their supported communication standards.

\paragraph{Device} It represents entities that interface with or are part of the external environment, such as sensors (\eg, cameras, laser rangefinder, GPS), actuators (\eg, motors, valves, pumps), or peripheral I/O. A device component has a dual software and hardware nature, since, as an abstraction, it can be used to model the physical component together with its driver; this means that a device support both ports and subprogram accesses to communicate with software components and bus accesses to interact with hardware components. The subcomponents available for the device are used to better describe the interaction between the external element and the system; a virtual bus can be used to specify the protocol of the communication, a bus to model the physical connection provided and a data component to capture the type of the data exchanged.

\subsection{Composite and generic components}
System and abstract component categories are not directly associated neither to software nor to hardware components, they are used to define conceptual and generic constructs. They provide to AADL the tools necessary to support modular and reusable models, by aggregating component together and by providing partially defined interfaces that can be refined during successive design phases.

\paragraph{System} It is an abstraction that represent a composite component (\ie, a container for other components). It can include software, execution platform or other system components with no restrictions. This means that it is possible to create system containing only hardware components (\eg, a processor board), only software components (\eg, a software control system), a combination of software and hardware (\eg, a complete embedded system),  or a combination of all these as direct subcomponents or as contained in other systems. Even the extreme case of a system consisting only of system components can be used as a generic representation of a component-based architecture. Given its nature as a container and aggregator, any type of component is an admitted subcomponent of a system. Although the aggregation defined by the system is only conceptual, it creates an actual frontier between the subcomponents inside and those outside; this means that any communication needs to go through features (\ie ports and accesses) defined on the system.

\paragraph{Abstract} It is a generic component category that can be used to declare a component type and implementation without specifying a specific category. By using this component as the only category in a system it is possible to create a conceptual component-based view of an architecture. Alternatively, by combining abstract and normal components in a system definition a designer can define a reference architecture to be specialised when necessary. Lastly, abstract components can be used to create partially defined components that act as libraries of design patters. Abstract categories can be refined in any other category, for this reason any component (software or execution platform) is admitted as a subcomponent. The same is true for properties, since the abstract category support every possible property. However, when an abstract component is refined to an actual category, only the properties and subcomponents admitted for that category are valid.

\subsection{Components interactions}
In AADL, there are multiple ways to define interactions between components. In the previous section, we described software and hardware categories and, by doing so, we introduced  two basic form of interaction: subcomponents and bindings. The most straightforward form of interaction is the relationship between components and subcomponents; models are described in a hierarchical way where higher level components are composed by lower level subcomponents and the designer can decide his own level of granularity for the architecture. For example, a system can be modelled down to the executable routines, but with no hierarchy definition in the middle (\ie, a subprogram in a thread contained in a process inside a system), or defined only conceptually by using a strict hierarchy of the components (\ie, system of systems containing only processes as subcomponents), or any intermediate combination. Components have direct access to their subcomponents at any depth, using a dot notation similar to object-oriented design (\eg, \texttt{system.process.thread.subprogram}). The concept of binding is specifically designed to relate software and hardware components. A memory component binds multiple data components to specify the physical location of the variables they model, or a process is bound to the processor that will execute it. In practice, this can be seen as the deployment of software on a specific hardware and it is fundamental to perform analysis of operational properties (\eg, performance, latency, fault tolerance), simulate the execution of the system and generate the build configuration.

The main form of interaction between different component is the use of connections. They are a very versatile form of interaction and they can represent a multitude of types of communications (\eg, remote function call, message passing, inter-process communication, variable access, interrupts), the differentiation of the communication protocol is achieve by defining externally visible features on components (\ie, interfaces on the frontier of a component). There are five different types of feature (ports, access, groups, abstract and parameters) and each of them has subtypes depending of the type of  information exchanged (\eg, data or events) or the component they are defined on (\eg, bus access or data access). Since subprogram are used to model procedures, functions, methods or, in general, any callable routine, they support two unique form of communication: parameters and calls. The former, as the name evoke, defines the relationship between data components and subprograms; the latter represents the sequence of execution of multiple subprograms.

\paragraph{Ports}
Ports are the most straightforward type of features. They are an interface for directional transfer of data, events or both into or out of a component. Compatible ports (see Table~\ref{tab:ports}) can be connected to define directional pathways for such transfers between components. Ports are defined in the component type declaration and are specified by name, direction, type and a data identifier. The name has to be unique in the scope of the component and it can be used to recall the port, both inside (directly) or outside (via dot notation) the component to define properties and connections. There are three possible options for the direction of a port: \texttt{in}, to specify an input, a flow of data or events from outside the component, \texttt{out}, represents an output, data or events coming from the component, \texttt{in out}, a bidirectional port, both input and output, this type of port supports incoming and outgoing connections. Three different types of ports are supported, and they represents different type of communications between components. Event data ports are meant for asynchronous communications, for example messages exchange. They model asynchronously sending and receiving data and the presence of a queue to store unprocessed messages while the receiving component is busy. Data ports are similar, since they model data exchanges, but without a queue. They are sampling ports, they retain only the most recent arrival. In the definition of both these types of ports it is possible to specify a data identifier that model the nature of data exchanged in the communication. Event ports represents triggers for discrete events and they carry no data. They can be used to model all kind of external events, from low level hardware interrupts, to signals from the operating system.

\begin{table}
    \myfloatalign
    \begin{tabularx}{\textwidth}{X | X | X | X}
        \toprule
        From/To  & \texttt{data} & \texttt{event data} & \texttt{event}   \\
        \midrule
        \texttt{data}  & Yes & Yes & Yes   \\
        \texttt{event data}  & Yes & Yes & Yes   \\
        \texttt{event}  &  &  & Yes   \\
        \bottomrule
    \end{tabularx}
    \caption[Inter-port compatibility]{Inter-port compatibility.}  \label{tab:ports}
\end{table}

\paragraph{Data and bus accesses}
In a system there are multiple shared resources, for example memories, log files, communication channels, sensors, input and output devices. In AADL, most of these resources are characterised by two component categories: data and bus. To model the concurrent access of components to these shared elements it is possible to use access features. Two types of access features exist: data access and bus access. Their conceptual definition and syntax is almost the same, the only exception is the use of the right keyword when referring to one or the other type. In the feature definition, they are identified by an unique name, that can be used to refer to a specific access in the model. Similarly to ports, accesses have a direction, but it is achieved by defining either  a requires access feature, indicating that a component needs access to a shared resource, or a provides access feature, meaning that a component allows access to a shared resource defined as a subcomponent within it. Optionally, it is possible to specify, in the definition of the access, a component identifier referring to a specific data or bus classifier, depending on the type of access. As any other feature, path between accesses are created using connections, differently from other features, the chain of connections in and out components does not end in a feature, but it continues to the shared resource. Connection between access features can be bidirectional ($\leftrightarrow$) or directional ($\rightarrow$); a bidirectional connection means the access allows both writing and reading operations, while with a directed connection, reading is allowed if the shared resource is the source and writing is allowed when it is the destination.

\paragraph{Subprogram calls and accesses}
As described before, a subprogram represent a unit of executable code, however a single unit or even a collection of them is not enough to describe the behaviour of a process; it is necessary to define the execution sequence. With AADL, it is possible to use different approaches to model the interaction between multiple subprograms, their local execution order and remote triggering. The main tool available is the call sequence defined in the \texttt{calls} section of a thread, inside the sequence, identified by a name, the reference to the subprogram can be modelled in three ways. First option is to specify only the subprogram classifier, this approach can be used to just identify the subprogram and leave the actual local instance implicit. Alternatively, it is possible to define a binding between the called subprogram interface and the actual instance by using the property \textit{Actual\_Subprogram\_Call}, this option is useful to model remote procedure calls or to define the implementation in a single location and then reference it in multiple places. Last option is to reference a subprogram access; this type of feature access works in the same way as a data or bus access, it provides or requires access and specify the category of the reference subprogram. The key difference is that the connection between two subprogram accesses is always bidirectional since the source is defined in the call sequence and an executable routine is expect to return to the caller.

\paragraph{Feature groups}
They represent a collection of component features or other feature groups. Feature group types, \ie, a set of component features, defines the internal structure of the group, they can be composed of any type of feature with any direction (\ie, any in and out port and any provides and requires access). Feature groups have multiple applications, for example can be used to simplify the model at higher level of details, or to model multiple communication channel always operating together, or to provide an abstract definition of a component to be refined later. On the component frontier, only the feature group is visible, and connection can be defined only between groups with the same type. Inside the component, the feature group acts as a reducing interface where all the compatible internal features converge.

\section{AADL for robotics}
The Architecture Analysis \& Design Language was originally developed in the field of avionics, then it was redesigned to target embedded real-time systems; therefore, never in its history the language was specifically designed for robotics. However, a lot of parallels exists between embedded and robotics systems, consequentially, characteristics that were designed for the former are more than suitable for the latter. Moreover, a general design approach means the language is not bound to a specific field and its design was not conditioned by the existing methodologies and technologies. Its agnostic nature makes AADL an excellent choice to provide a general modelling language for robotic systems, different middlewares and frameworks sharing similar design principles can be represented easily with a common language. Moreover, AADL formal syntax and expressiveness guarantee consistency in the models and reduce the necessity to introduce extensions and ad hoc modifications, and even when this is necessary, it is regulated by the language itself.

As described in the previous section, AADL provides modelling tools for both hardware and software components. This is expected from a modelling language designed for embedded systems, where the development of the software components is tied to the hardware platform, however, this characteristic is extremely useful for robotics, too. Thanks to the abstraction provided by component-based middlewares, modern robotic systems are not tightly connected to the underlying hardware platform as they used to be; today an obstacle avoidance system does not need to know exactly the data format of the measurements provided by the laser rangefinder to work correctly. However, this is true only for the development of single components or compartmentalised set of components, when designing the whole system or during execution, it is necessary to take in account the behaviour of both hardware and software. \textit{How many and which sensors the robot uses to localise itself? Is there a teleoperation system? How much time it takes for a measurement to propagate in the system? How many critical functionalities are interrupted by a faulty sensor or actuator?} All these critical questions have to be answered during the design phase of the system, and this can be done by correctly modelling the hardware (sensors, actuators, connections, execution platforms, \etc), the software (drivers, low-level interfaces, functionalities, \etc), and their interactions.

In AADL, a designer can use properties to specify the finer characteristics of each component. Some examples are the size of a memory, the computational power of a processor, the resources used by a process, or the throughput of a connection. All these properties can be used to perform a formal analysis of the system before deployment, or even before the implementation. One of the tools provided by AADL is the concept of flow, they are logical path through the architecture and they are specified from a component input to a component output. These flows can go through any type of feature (\ie, ports, accesses, groups and abstracts) and can represent any logical pathway (\eg, data, control, fault event, \etc). When modelling a flow, it is necessary to specify the source, the sink and the complete path of the flow, however, the definition can be done at system-level, it is not necessary to specify the behaviour of the flow inside the components. From this specification, it is possible to do end-to-end analysis, for example, identify the component involved in a critical communication, estimate the propagation of an error, calculate the time necessary for a measurement to impact on the behaviour of an actuator. Information and analysis about propagation time of messages and latency are fundamental in hard real-time application, but even soft real-time application can benefit from a strict performance analysis. For example, an high-speed delta robot need to consider communication latency to operate with high precision, or in an autonomous wheelchair, while the control system doesn't need high reactivity given the speed involved, a correct estimation of the latency will make the difference between a sudden braking and a gentle slowdown when faced with an unexpected obstacle.

On a more technological level, the detailed description of components, their interactions, their structure and hierarchy provided by AADL is extremely useful to solve some intrinsic problems of robotic middlewares. For example, if we consider ROS, there is a total absence of an architectural view of the system. A partial representation of the interactions of the components is available at runtime by using tools like \texttt{rqt\_graph}, but this representation only consider topics and does not reflect the full structure of the system. Something similar can be achieved during deployment by using launch files, but while they are useful to organise the runtime of the components, there is no way to visualise the interactions between them and they do not capture the internal connections. Both this limitations can be solved by using AADL, a complete model of the architecture provides a view of the system since its inception and by using the \textit{system} component is possible to recreate the same hierarchy provided by launch files. Even when considering middlewares more focused on a model based approach, AADL can bring great advantage. In the SmartMDSD toolchain, architectures are designed using a custom meta-model defined via the Eclipse Modelling Framework, this approach limits the design process to a very specific environment and tightly connects the design phase with the implementation phase, since the model reflect exactly some specific software artefacts. Moreover, while quite complete, the SmartMDSD meta-model, do not consider the hardware components as part of the architecture, therefore any analysis related to the hardware has to be done with additional tools. In this case, AADL could be used as a general high-level modelling language compatible with the SmartMDSD meta-model, to be then transformed in an intermediate representation compatible with the existing code generators. The AADL version of the model could be used to perform analysis and to speculate on the possibility of using different technologies to implement different components, or to deploy the same design on different platforms.

While not strictly related with robotics, an important feature of the language is the active community, and the available tools. The Open Source AADL Tool Environment (OSATE) is a development environment not only to develop AADL models both graphically and textually, but also to exploit all the validation and analysis capabilities of the language. Some examples are: end-to-end latency analysis, port connections consistency checks, computer resources budget analysis. Moreover, OSATE act as an interface for the capabilities provided by Ocarina, an AADL model processor that supports parsing, code generation and model checking. Ocarina uses a front end/back end paradigm, where the front end is the AADL parser and a back end can be any code generator that goes from the intermediate representation provided by the front end to an executable code. Ocarina already support various targets for code generation, none of these is a robotic middleware, however, thanks to the front end/back end paradigm, we managed to create a suitable code generator that goes from an AADL model to a complete ROS architecture.

\section{AADL and the C/C paradigm}
\label{sec:aadl-cnc}
AADL is the perfect candidate to describe architectures based on this paradigm, because the language itself, while centred around the concept of schedulability of threads, is designed to support the structure defined by components and connections. AADL components, at any level (\eg, systems, process, device, subprogram, \etc) support, some form of feature (\ie, ports and accesses) to communicate and interact with other components. In the previous section we described all the elements useful to characterise the robotic components and their interactions (\ie, component behaviours, type and cardinality of connections), in this section we will describe how the same concept can be modelled by using AADL.

First of all, it is necessary to outline which AADL artefacts are necessary to model this kind of paradigm. As described in Section~\ref{sec:aadl}, the general top level container is the \textit{system} category, one step below there are three possible software categories that could act as components: \textit{process}, \textit{data} and \textit{subprogram}. A collection of subprograms as subcomponent of a system is used to model libraries or sets of APIs, data as first level subcomponents models general storage or shared resources, processes are used to describe an enclosed execution space and can exist only as direct subcomponents of a system. Therefore, it is clear that the perfect candidate to model components in the component-and-connector paradigm is the \textit{process} category. Since the execution space of a process is directly accessible only by its own subcomponents, the category supports, on its frontier, all available AADL features (\ie, interfaces). 

We described in the previous section how communication can be data or event based, AADL supports both this types of communication thanks to the additional type specifier when defining a feature, it can be a \textit{data port}, an \textit{event port} or an \textit{event data port}. Moreover, ports can be characterised by a specific data type, defined using a \textit{data} category, this is useful to model the type of message exchanged in the connection. In AADL, all ports have natively a \textit{n-n} cardinality, with the exception of the \textit{input data port}; since this type of port models a communication with no queue, it does not support multiple incoming connections, however they are supported by the \textit{input event data port} since it includes a queue in its model. In the base language, there is no way of restricting the cardinality of ports, but it is possible to define extra properties to better specify a connection and, eventually, indicate its cardinality.

To model component behaviours, it is necessary to go a step further in the component hierarchy and to take in account the potential subcomponents of a process. Again, the \textit{data} and \textit{subprogram} categories are potential subcomponents, but are not relevant to describe the behaviour of a component, since they are used to define memory and subroutines. The third, and more suitable, candidate is the \textit{thread} category. They represent an execution path through code and their execution behaviour is periodic with various characteristics or triggered by an external input (\eg, external incoming data or events), moreover, multiple threads can co-exist in the same process and, eventually, execute in parallel. All this characteristics make the thread a suitable category to model component behaviours. However, as we described in the previous section, each behaviour is related to a specific interaction outside the frontier of the component, therefore to completely characterise it, it is necessary to combine a thread with a specific port:
\begin{itemize}
\item Source: in this behaviour the components generates messages or events. Therefore the thread needs an output port that can be of type data or event. Since there is no external source triggering this behaviour, it is necessary to specify the scheduling of the thread, usually periodic.
\item Sink: in this case the components receives and consumes messages or events. Given this, an input port needs to be modelled as interface of the thread. By changing the type of the input port it is possible to slightly change the how the skin behave. A data port, combined with a periodic scheduling, would model a sampler that receive a constant stream of data, an event data port would define the subscriber of a publish/subscribe paradigm, an event port defines a sink managing external triggers.
\item Filter with memory: for this type of behaviour it is necessary to add the extra memory element, in AADL all memory, on a software level, is modelled using the \textit{data} category. Therefore, to completely model this type of filter, it is necessary to define a data component inside the process that acts as a shared memory between two threads, one with a input port (\ie, sink equivalent) and one with an output port (\ie, source equivalent).
\item Filter without memory: this type of filter is easier to model, since there are less elements. All processing happens directly in the thread that receive the message and the same thread is responsible to circulate it back in the architecture. Given this, this behaviour is modelled using a single thread with an input port of any kind and a corresponding output port.
\item Reactive: this behaviour represents a synchronous remote execution similar to a remote function call. In AADL there are various approaches to model a RFC, to keep the structure more in line with the other behaviours the best option is to pair a thread with a remote subprogram call. To do so, it is necessary to define a \textit{subprogram} as a subcomponent of a thread and, on the frontier, declare an access bound to that specific subprogram.
\end{itemize}

%TODO maybe I should add here something about devices.

\subsection{A basic example}
With the paradigm described in Section~\ref{sec:cnc} and the tool provided by AADL presented in Section~\ref{sec:aadl-cnc}, it is possible to define a basic architecture, not only the topology of the connections, but also the internal functioning of the components. As an example, let us take the architecture defined in Figure~TODO; in this simple architecture we want to model a robot with two control functionalities: line following and teleoperation.

In the top branch of the architecture we have the line following subsystem: a sensor driver that generates measurements indicating the presence of a black line on the ground and a simple component that directly translate the sensor input in a velocity command. The former expresses a \textit{source} behaviour, it generates messages and circulates them in the system, it is modelled by a process containing a periodic thread, on the frontier there is a output data port. The latter has a \textit{filter} behaviour, it has two ports on its frontier: one input event data port, to queue the messages and trigger a functionality of the component, and one output data port, to send to the next component the velocity commands. In this example, the line following component is very simple and can estimate a set-point directly from the sensor measurements, this means that it doesn't need to store any information, therefore it is a filter without memory. The internal model of the components is a single thread with an input and an output port, both directly connected to their corresponding ports on the process frontier.

On the bottom branch there is the teleoperation subsystem: a joypad driver providing readings of the input and a teleoperation component to convert the joypad input in set-points. Similarly as the other branch, the driver expresses a \textit{source} behaviour, it converts the input coming from the joypad in messages compatible with the architecture. The teleoperation component, however, does not have the same \textit{filter} behaviour of the line follower, since it stores the incoming messages to smooth the set-point, it means the component is a filter with memory. To model it, it is necessary to define on the frontier of the process two ports: one input event data port and one output data port. Internally, these two ports are connected to two different threads, one is triggered by the event data port, it receive the messages and store them locally. The output data port is connected to a periodic thread, on fixed intervals it reads the two most recent messages and estimate a single set-point compatible with the robot acceleration. Each thread has its own data access to write or read on the shared memory area, modelled as a data component.

In the middle of the architecture, to mediate between the two different control systems, there is a multiplexer component. This is an example of multiple behaviours co-existing in the same component. There are two filters, one for each input, their functionality is to relay the correct input to the output and only one of the is active at a given time, additionally there a \textit{reactive} behaviour. One of the two inputs (\ie, line following or teleoperation) can be selected by triggering a remote function call on the component, which changes a local variable specifying the active input. To model this component it is necessary to define four different features on the frontier: two input event data port, they are the receiving side of the two filters, one output data port, it selectively relays the selected input, and one subprogram access, to trigger the reactive behaviour. Internally, each input port is connected to an independent thread, triggered by the port itself, this threads receive the inputs and store them in a shared memory area. The output port is connected to a periodic thread, which reads the content of the inputs from the shared memory and publish the selected one. The subprogram access interfaces with a thread which has the corresponding subprogram as a subcomponent, this thread is triggered by an external call on the access and changes the current selected input. All the threads have a data access to the same data component representing the shared memory area.

The last element of the architecture is the control component. It is directly connected to the hardware of the robot and consume the set-point provided by the multiplexer to operate the motors, in summary, it expresses a \textit{sink} behaviour. It is modelled by a process containing a single thread, which is connected and activated by the event data port defined on the frontier of the component.

\section{From C/C to ROS}
Lorem ipsum

\subsection{Robot operating system}
Lorem ipsum

\subsection{ROS templates}
Could be an independent subsection or part of the previous one

\section{Data Modelling}
Lorem ipsum

\subsection{ASN.1}
Lorem ipsum

\subsection{JSON}
Lorem ipsum

\subsection{JSON schema}
Lorem ipsum

%*****************************************
